# Introduction to Audio Module Setup Files

## What is an "audio module"?

An audio module within the PixelPerfectEngine ecosystem is similar to plugins in DAWs, with the following differences:

* Audio modules by default don't have any GUI. Certain editor suites might have them in the future for certain modules,
for easier setup and configuration by more ordinary musicians (ones without programming knowledge), but by default,
they're not coded directly into the module.
* Optimization for performance and simplicity. While audio quality is still important, there might be certain 
sacrifices made for performance gains and easier maintance over functions or minor artifacts.
* Due to this reason, many instrument modules don't have polyphony capability by their own, instead the composer must
distribute the notes manually across multiple channels. This also eliminates any errors caused by uncertain scenarios.
* Hardcoding. Since there's not too much to gain by making each module its own dynamic link library besides a smaller
executable, it won't be done.

Instrument-type audio modules can create music and various sound effects on the fly, while effect-type audio modules
can alter their outputs. Streaming-types will be used in the future to stream audio data from disk, network, etc.

## What is an "audio module setup file"?

To configure routings of audio modules, recall their parameters, and load samples into them, a special file format
based on SDLang have been developed for this purpose.

# Metadata

All metadata goes into the root tag `Meta`. Not used by the setup process, but has some standardized elements.

# Nodes

The `Nodes` root tag contains the names of all existing audio routing nodes except for the output ones. These are 
addressed by name in the routing setup, to allow multi-channel scaling.

It should look something like this:

```s
Nodes {
    "reverbIn_L"
    "reverbIn_R"
    "chorusIn"
}
```

Note that nodes with the naming formats `output#`, `output##`, and `outputLF#` are reserved, and should be generated by
the program during runtime for outputs. Node-to-node routing directly is not possible, you'll need to set up a module 
first.

Nodes can be created conditionally, see condition codes chapter.

# Module

The `Module` root tag contains module configuration information, including preset data and routing.

```s
Module "QM816" "fmsynth" {...}
```

Modules can be created by condition if needed.

## Sample loading

To load a sample into the module, just simply use:

```s
loadSample "drum.wav" 56 dpk="instruments.dpk"
```

Where the first parameter is the filename in string format (can be unicode), the second parameter is the sample ID in 
unsigned 32 bit integer format, and the `dpk` optional attribute tells if the file is in a datapak file and where it
can be found.

## Routing setup

Every input or output can be only routed to one node, but a single node can be read or be written by multiple modules.

The routing works as such:

```s
route "mainL" "outputL"
route "mainR" "outputR"
route "auxSendA" "chorusIn"
```

Where the first string is the source, and the second one is the destination.

Conditional routing can be set if needed.

## Preset recall

To recall preset parameters, just simply use:

```s
paramRecall 81 {
    "level" 1.0
    87923045L 0.56
    ...
}
```

Where the first parameters in the nameless tags are the parameter identifiers, and the second parameters are the values 
themselves (int, uint, double, and string are allowed). Usually preset identifiers work something like this:

* bits 0-6: preset number
* bits 7-20: bank number

# Condition codes

The following condition codes exist:
* `ifNodeExists`
* `ifNodeNotExists`
* `ifHeadphones`
* `ifSampleRate`
* `ifSampleRateMin`
* `ifSampleRateMax`

## Example use

```s
module "Reverb" ifNodeExists="rearL&rearR" {
    loadSample "hall.wav" 1
    loadSample "room.wav" 2
    route "auxSendB" "inL"
    route "auxSendB" "inR"
    route "outL" "rearL"
    route "outR" "rearR"
}
```
