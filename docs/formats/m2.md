# The M2 format

## Background and rationale behind creating the M2/MDL formats

* There's no known MIDI 2.0 file formats.
* Most other music command file formats also lack extensions for creating adaptive soundtracks.

## General guidelines

* Make the format easy to process by the sequencer.
* Make it based on RIFF and similar data serialization formats.
* Give it branching capabilities for adaptive soundtracks.

# Version history

Preimplementation versions included a human-readable version based on SDLang.

# Magic bytes

Every m2 file must begin with `MIDI2.0`, and a file version identifier byte (null for first initial version).

# Binary chunk layout

## Chunk header:

`ID` = 8 bytes, ASCII characters, unused ones padded with nulls.

`length` = 64 bit unsigned integer. Equals with the length of the chunk not counting header and footer.

## Chunk footer:

`checksum` = 4 bytes, CRC32 checksum of the chunk data. Not used if chunk length is zero.

# Header format

Identifier: `HEADER`

## Binary layout

* `timeFormatID` = 1 byte. 0 = miliseconds, 1 = microseconds, 2 = hnsecs, 3 = custom period based.
* `timeFormatPeriod` = 3 bytes, unsigned integer, the period of which time format 3 is based on, zero in all other time formats.
* `timeFormatRes` = 4 bytes, unsigned integer, the resolution of time format 3.
* `deviceNum` = 2 bytes, number of valid devices excluding the sequencer.
* `maxPattern` = 2 bytes, maximum number of patterns at once.

# Command list

## null command

Bytecode layout:

```
[00]{00|00|00}
```

Doesn't do anything. In bytecode, the word must be set to all zeroes

## wait command

SDL layout:

Bytecode layout:

```
[01]{24 bits of time value}
```
or
```
[02]{24 most significant bits of time value}{32 least significant bits of time value}
```

Makes the sequencer wait between chains of commands by the given amount. Type of amount is set by the header.

This command have two different bytecodes in case a single 24 bit wait time isn't enough in certain cases.

## emit command

Bytecode layout:

```
[03]{Amount: 8 bits}{Device: 16 bits}
```

Emits a given amount of words of MIDI data to the targeted device. If more needed, then more must be chained together. One command ideally should target a single device. Device 65535 is the sequencer, and can be used for things like setting 

## Conditional jump command

Bytecode layout:
```
[04]{Amount of conditions: 24 bits}
{jump amount: 32 bits signed integer}
Conditions:
{Condition code: 8 bits}{Flags: 4 bits}{Misc code: 6 bits}{Value ID: 14 bits}
{Value to be checked against: 32 bits}
```

If the conditions are not met, then the sequencer will skip forward the given amount of words. If amount of conditions are zero, it'll always jump.

### Condition codes

* `0x00` = Equals within Misc
* `0x01` = Greater or equal 
* `0x02` = Greater than
* `0x03` = Less or equal
* `0x04` = Less than
* `0x05` = Not equal within Misc
* `0x06` = Increment by Misc2 while less than.
* `0x07` = Decrement by Misc2 while greater than.
* `0x08` = Previous condition was false.

### Flags

* Bit 0: If set, next condition will be ANDed to the rest, OR-ed otherwise.
* Bit 1: Toggles AND and OR into NAND and XOR respectively.
* Bit 2: Priority flag, if high this and the next condition will have a higher priority in evaluation. Works as an analogue to brackets.
 
## Inject pattern in parallel

```
[05]{Pattern ID: 24 bits}
```

Injects a pattern in parallel to the main song data. Cannot be used in patterns.

