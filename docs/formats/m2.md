# The M2 format

## Background and rationale behind creating the M2 formats

* There's no known MIDI 2.0 file formats.
* Most other music command file formats also lack extensions for creating adaptive soundtracks.

## General guidelines

* Make the format easy to process by the sequencer.
* Make the binary based on RIFF and similar data serialization formats.
* Give it branching capabilities for adaptive soundtracks.
* Create a human readable format similar to Music Markup Language formats.

# Version history

Preimplementation versions included:
* A human-readable version based on SDLang (dropped in favor of MML-like implementation).
* A more complicated conditional jump system (dropped in favor of a simpler one using various operations to achieve the same effect).

# Magic bytes

Every m2 file must begin with `MIDI2.0`, and a file version identifier byte (zero for first initial version).

# Notes on human-readable format

## General rule

Each line is simply ended with some CR-LF combination the OS use. Readers must make processing OS agnostic.

## Note format

The note describing character sequence consists of 
* a letter (case insensitive), 
* a symbol (either `-`, `#`, or `b`),
* one or more numbers (-1 and -2 octaves are symbolized as `00` and `000`)

Examples: `c#000`, `d-5`, `Bb3`.

## Rhythm format 

The rhythm describing character sequence consists of 
* an optional number to describe triplets,
* one letter to describe note length,
* one or more dots to describe dotted rhythm.

Multiple rhythms can be added together with the plus (`+`) symbol.

### Recognized letters:
* `w`: whole note.
* `h`: half note.
* `q`: quarter note.
* `s`: sixteenth note.
* `t`: 32th note.
* `i`: 64th note.
* `x`: 128th note.
* `y`: 256th note.
* `z`: 512th note.
* `u`: 1024th note;

Examples: `w`, `h+s..`, `3q`, `5t.`

Associating it with pitch in macros is done in the following ways:
* A colon is used to directly assign a duration to a pitch: `w:c-4 h.:e-4 h..:g-4`.
* A `~` symbol will assign it for all the notes in the current macro: `w~ c-4 e-4 g-4`
 
## Comments

Anything put after a semicolon will be ignored until the end of the line.

## Number formats 

Hexadecimal numbers are designated with an `0x` at the beginning, e.g. `0xff`. All numbers can be decimal separated with an underscore, e.g. `123_456_789`, `0xff_ee_dd_cc`

# Binary chunk layout

## Chunk header

`ID` = 8 bytes, ASCII characters, unused ones padded with nulls.

`length` = 64 bit unsigned integer. Equals with the length of the chunk not counting header and footer.

## Chunk footer

`checksum` = 4 bytes, CRC32 checksum of the chunk data. Not used if chunk length is zero.

# Human readable chunk layout

## Chunk header

`[ChunkID] {ChunkName}`

ChunkID is the same as in the binary format. ChunkName is used to designate chunks if applicable (patterns, etc) for easier human readability.

## Chunk footer

`END`

Chunks are simply closed with an `END`. Chunks must not be cascaded or embedded into each other, for that reason any other block should be closed with an all-lowercase `end`.

# Header format

Identifier: `HEADER`

## Binary layout

* `timeFormatID` = 1 byte. 0 = miliseconds, 1 = microseconds, 2 = hnsecs, 3 = custom period based (whole number), 4 = custom period based (16bit whole + 8 fraction), 5 = custom period based (8bit whole + 16 fraction).
* `timeFormatPeriod` = 3 bytes, unsigned integer, the period of which time format 3/4/5 is based on, zero in all other time formats.
* `timeFormatRes` = 4 bytes, unsigned integer, the resolution of time format 3/4/5.
* `deviceNum` = 2 bytes, number of valid devices excluding the sequencer.
* `maxPattern` = 2 bytes, maximum number of patterns at once.
* `patternNum` = 4 bytes, unsigned integer, total number of patterns.
 
## Human readable format

* `timeFormatID [fm]`: Format can be ms = miliseconds, us = microseconds, hns = hnsecs, fmt3, fmt4, fmt5
* `timeFormatPeriod [int]`: Can be either a decimal or hexadecimal number as long as it's differentiated (see chapter on human readable format).

# Command list

## null command

Bytecode layout:

```
[00]{00|00|00}
```

human-readable format:

```
nullcmd
```

Doesn't do anything. In bytecode, the word must be set to all zeroes

## wait command

Bytecode layout:

```
[01]{24 bits of time value}
```
or
```
[02]{24 most significant bits of time value}{32 least significant bits of time value}
```

Human-readable format:

```
wait {int}
```
or
```
wait {rhythm code}
```

Makes the sequencer wait between chains of commands by the given amount. Type of amount is set by the header in bytecode format, or a rhythm code set to the current pattern's rhythm.

This command have two different bytecodes in case a single 24 bit wait time isn't enough in certain cases.

## emit command

Bytecode layout:

```
[03]{Amount: 8 bits}{Device: 16 bits}
```

Human-readable format:

```
e[DeviceID]: [MIDI command in one line]
```

Emits a given amount of words of MIDI data to the targeted device. If more needed, then more must be chained together. One command ideally should target a single device. Device 65535 is the sequencer, and can be used for things like settings. In human-readable form, each MIDI command is translated to a human-readable format (see chapter on human-readable format).

## Conditional jump command

Bytecode layout:
```
[04]{condition code: 8 bits}[aux byte A, aux byte B]
{Condition mask: 32 bits}
{jump amount: 32 bits signed integer}
```

Human-readable format:
```
jmpXX [condition mask] [position label]
```

If the condition is true to local register #127 (which is compare code target), then the sequencer jumps forward or backward by the given amount. In human readable form, position labels are used instead. Note: macros for `if-elseif-else` do exist

### Condition codes 

* 0x00/nc: Jump always.
* 0x01/eq: Jump if equal with CR with condition mask.
* 0x02/ne: Jump if not equal CR with condition mask.
* 0x03/sh: Jump if at least one bit is high in CR from condition mask.
* 0x04/op: Jump if all bits are opposite between CR and condition mask.
 
## Inject pattern in parallel

Bytecode layout:
```
[05]{Pattern ID: 24 bits}
```
Human-readable form:
```
chain-par [patternName]
```

Injects a pattern in parallel to the main song data. Pattern cannot chain itself into the the song, and will be ignored.

## Inject pattern in series

Bytecode layout:
```
[06]{Pattern ID: 24 bits}
```
Human readable form:
```
chain-ser [patternName]
```

Injects a pattern in series into the main song data: executes the referenced pattern, then returns to the current position once finished. If used to refer the current pattern, it'll simply reset it.

## Math operations on registers

Bytecode layout:
```
[Op]{RA}{RB}{RD}
```
Human-readable form:
```
[oper] [RA] [RB] [RD]
```

Does math or logic operations on registers. Note: RB is used as an intermediate value for binary shifts

### Possible operations:

* 07/add: RA + RB = RD
* 08/sub: RA - RB = RD
* 09/mul: RA * RB = RD
* 0a/div: RA / RB = RD
* 0b/mod: RA % RB = RD
* 0c/and: RA & RB = RD
* 0d/or: RA | RB = RD
* 0e/xor: RA ^ RB = RD
* 0f/not: ~RA = RD
* 10/lshi: RA<<[RB] = RD
* 11/rshi: RA>>[RB] = RD
* 12/rasi: RA>>>[RB] = RD
* 13/adds: RA + RB = RD (signed)
* 14/subs: RA - RB = RD (signed)
* 15/muls: RA * RB = RD (signed)
* 16/divs: RA / RB = RD (signed)
* 17/lsh: RA<<RB = RD
* 18/rsh: RA>>RB = RD
* 19/ras: RA>>>RB = RD
* 1a/mov: RA = RD
 
## Compare operation

Bytecode layout:
```
[1b]{cc}{RA}{RB}
```
Human-readable form:
```
cmpXX RA RB
```

Compares two registers, then shifts a bit into CR to the least significant position, 1 if true, 0 otherwise.

### Condition codes

* 01/eq: RA == RB
* 02/ne: RA != RB
* 03/gt: RA > RB
* 04/ge: RA >= RB
* 05/lt: RA < RB
* 06/le: RA <= RB