# The M2 format and the Music Declaration Language

## Background and rationale behind creating the M2/MDL formats

* There's no known MIDI 2.0 file formats.
* Most other music command file formats also lack extensions for creating adaptive soundtracks.

## General guidelines

* Make both a human-readable version, and a binary (byte-code) one too.
* For the human-readable version, use either the original SDL-parser, or a modified version of it.
* Make things like note numbers and time durations to be able to be inputted in easy to understand way.
* The binary version should be easy to process to the sequecer.
* Make some branching capabilities to aid the composition of adaptive music.

# Header format

# Command legends and macros

## General legends

* `[Mandatory parameter](Type)`: This is a mandatory parameter of the given command. Type must match.
* `[Mandatory parameter](Type1)/(Type2)`: This mandatory parameter can have multiple types. Note that strings have their own subtypes too.
* `{Optional attribute}(Type)`: Sometimes commands will have optional parameters. They're named, and can have multiple type options on occassion.

## Note duration macros

Musical rhythm-based times are supported by the MDL format, as string macros.

* Whole notes are `w`, half are `h`, quarter are `q`, and eigth are `e`.
* Furhter subdivisions can be achieved with stacking other divisions before any eigth note, `he` is a sixteenth note, `hee` is a 128th note, etc.
* Dotter rhythms are done with adding one or more `d` to the notes.
* Numbers written after the notes create "triplets", like `he3`.
* These must be added with the plus symbol, like `w+q`or `q+hedd`.

## Note macros

Notes can be inputted in the following fashion:

`C-5`, `D#0`

Multiple notes can be stringed together by putting space between them, for chords:

`C-5 E-5 G-5`

Notes and durations can be paired up with the `~` character if chord notes need different durations each

`D-5~w F-5~q A-5~qd`

Note that chords will be converted to individual note-on and note-off commands.

## Byte code layout

The most significant 8 bits are the main command code. The rest can be either parameters, or further command codes, e.g. in case we run out of the 256. A single command can be multiple words, and variable-length commands must have a length identifier somewhere to check for length, e.g. by a length parameter.

# Command list

## null command

SDL layout:

```s
null;
```

Bytecode layout:

```
[00]{00|00|00}
```

Doesn't do anything. In bytecode, the word must be set to all zeroes

## wait command

SDL layout:

```s
wait [time](integer)/(long)
```

Bytecode layout:

```
[01]{24 bits of time value}
```
or
```
[02]{24 most significant bits of time value}{32 least significant bits of time value}
```

Makes the sequencer wait between chains of commands by the given amount. Type of amount is set by the header.

This command have two different bytecodes in case a single 24 bit wait time isn't enough in certain cases.

## emit command

SDL layout:

```s
emit [Device](integer)/(string) {
    ...
}
```

Bytecode layout:

```
[03]{Amount: 8 bits}{Device: 16 bits}
```

Emits a given amount of words of MIDI data to the targeted device. If more needed, then more must be chained together. One command ideally should target a single device. Device 65535 is the sequencer.

See chapter on how to write-in MIDI 2.0 commands if needed.

## if command

SDL layout:

```s
if [Conditions](string) {

}
```

Bytecode layout:
```
[04]{Amount of conditions: 8 bits}{Amount of words need to be jumped over if false: 16 bits}
Conditions:
{Condition code: 4 bits}{Condition chain code: 4 bits}{Bracket code: 4 bits}{Margin of Error code: 6 bits}{Value ID: 14 bits}
{Value to be checked against: 32 bits}
```

If the conditions are not met, then the sequencer will skip forward the given amount of words.

### Condition codes

## else command