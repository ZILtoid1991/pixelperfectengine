module pixelperfectengine.audio.modules.qm816;

import pixelperfectengine.audio.base.modulebase;
import pixelperfectengine.audio.base.envgen;
import pixelperfectengine.audio.base.func;

import midi2.types.structs;
import midi2.types.enums;

import inteli.emmintrin;

import bitleveld.reinterpret;

import std.math;

/**
QM816 - implements a Quadrature-Amplitude synthesizer. This technique was used in early 
digital FM synths, since it allowed allowed a cheap implementation of the same thing as
long as the modulator was a sinusoidal waveform.

It has 16 2 operator channels that can be individually paired-up for 4 operator channels,
for more complex sounds. Also all operators have the option for feedback, including 
carriers. 2 operator channels have 2, 4 operator channels have 3*4 algorithms.

The audio module generates a few default waveforms upon startup, but further ones can be
supplied from files, or generated by code. Some waveform generation code is already
supplied with the synth's code.
*/
public class QM816 : AudioModule {
	shared static this() {
		/+for (int i ; i < 256 ; i++) {
			SINEWAVE_FRAGMENT[i] = cast(short)(sin((PI_2 / 256) * i) * short.max);
		}+/
		for (int i ; i < 128 ; i++) {
			ADSR_TIME_TABLE[i] = pow(i / 64.0, 1.8);
		}
	}
	/**
	Generates a waveform from a sinewave fragment (quarter).

	q flags:
	bit 0 = If set, then the sine fragment is present. If not, this portion will be replaced with all zeros instead.
	bit 1-2 = Doubling mode:
		0 = No doubling.
		1 = Same cycle twice.
		2 = Same cycle mirrored, effectively putting a half-sine into a quarter with the right settings.
		3 = The second half is all zeros, the sine fragment is effectively "stuffed" into an eight of the waveform.
	bit 3 = Horizontal mirroring of the cycle.
	bit 4 = Vertical mirroring of the cycle.
	bit 5 = Modifies the curve of the sinewave for a bit more square-ish shape.
	*/
	public static short[1024] generateSinewave(ubyte[4] q) @nogc @safe pure nothrow {
		short sineWave(int i, bool shape) @nogc @safe pure nothrow {
			real val = sin((PI_2 / 256) * i);
			if (shape) {
				if (val > 0) return cast(short)(sqrt(val) * short.max);
				else if (val < 0) return cast(short)(sqrt(val * -1) * short.max * -1);
				else return 0;
			} else return cast(short)(val * short.max);
		}
		short[1024] result;
		for (int j ; j < 4 ; j++) {
			if (q[j] & 1) {
				const int offset = 256 * j;
				const int hMir = q[j] & 0x8 ? 256 : 0;
				//int hBegin = q[j] & 0x8 ? 255 : 0;
				//const int vOffset = q[j] & 0x10 ? -1 : 0;
				const int vMir = q[j] & 0x10 ? 512 : 0;
				const bool shape = q[j] & 0x20 ? true : false;
				//const short[256] fragment = SINEWAVE_FRAGMENT;
				switch (q[j]>>1 & 3) {
					case 1:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						break;
					case 2:
						for (int i ; i < 128 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						for (int i ; i < 128 ; i++) {
							result[offset + i + 128] = sineWave((((127 - i) * 2) & 255) + hMir + vMir, shape);
						}
						break;
					case 3:
						for (int i ; i < 128 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						break;
					default:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = sineWave(i + hMir + vMir, shape);
						}
						break;
				}
				/+const int offset = 256 * j;
				int hMir = q[j] & 0x8 ? -1 : 1;
				int hBegin = q[j] & 0x8 ? 255 : 0;
				const int vOffset = q[j] & 0x10 ? -1 : 0;
				const int vMir = q[j] & 0x10 ? -1 : 1;
				const short[256] fragment = SINEWAVE_FRAGMENT;
				switch (q[j]>>1 & 3) {
					case 1:
						hMir *= 2;
						for (int i ; i < 256 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					case 2:
						hMir *= 2;
						for (int i ; i < 128 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						hMir *= -1;
						hBegin = q[j] & 0x8 ? 0 : 255;
						for (int i ; i < 128 ; i++) {
							result[offset + i + 128] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					case 3:
						hMir *= 2;
						for (int i ; i < 128 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					default:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = cast(short)(fragment[hBegin + hMir * i] * vMir + vOffset);
						}
						break;
				}+/
			}
		}
		return result;
	}	
	/**
	Generates a pulse wave.

	`width` controls the pulse width.
	*/
	public static short[1024] generatePulseWave(int width = 512) @nogc @safe pure nothrow {
		short[1024] result;
		for (int i ; i < 1024 ; i++) {
			result[i] = i < width ? short.max : short.min;
		}
		return result;
	}
	/**
	Generates a triangular waveform.
	`shape` controls the shape of the triangular waveform, allowing it to be morphed between triangle, saw, and ramp.
	``
	*/
	public static short[1024] generateTriangularWave(int shape = 512) @nogc @safe pure nothrow {
		import pixelperfectengine.system.etc : clamp;
		short[1024] result;
		int state;
		const int upwardSlope = ushort.max / shape;
		const int downwardSlope = ushort.max / (1024 - shape);
		for (int i ; i < shape / 2 ; i++) {
			state += upwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		for (int i = shape / 2 ; i < (shape / 2) + (1024 - shape) ; i++) {
			state -= downwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		for (int i = (shape / 2) + (1024 - shape) ; i < 1024 ; i++) {
			state += upwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		return result;
	}
	/** 
	Contains a table to calculate Attack, Decay, and Release values.

	All values are seconds with factions. Actual values are live-calculated depending on sustain-level and sampling
	frequency.

	Current formula for the ADSR time table:

	yn = (x/64)^1.8
	*/
	public static immutable float[128] ADSR_TIME_TABLE;
	/**
	Contains a table to calculate Sustain control values.

	All values are seconds with fractions. Actual values are live-calculated depending on sustain level and sampling
	frequency. Please note that with certain levels of sustain, the actual max time might be altered.
	*/
	public static immutable float[63] SUSTAIN_CONTROL_TIME_TABLE = [
	//	0     |1     |2     |3     |4     |5     |6     |7     |8     |9     |A     |B     |C     |D     |E     |F
		70.00, 60.00, 55.00, 50.00, 45.00, 42.50, 40.00, 38.50, 35.00, 32.50, 30.00, 27.50, 25.00, 24.00, 23.00, 22.00,//0
		21.00, 20.00, 19.00, 18.00, 17.50, 17.00, 16.50, 16.00, 15.50, 15.00, 14.50, 14.00, 13.50, 13.00, 12.50, 12.25,//1
		12.00, 11.75, 11.50, 11.25, 11.00, 10.75, 10.50, 10.25, 10.00, 9.750, 9.500, 9.250, 9.000, 8.750, 8.500, 8.250,//2
		8.000, 7.750, 7.500, 7.250, 7.000, 6.750, 6.500, 6.250, 6.000, 5.750, 5.500, 5.250, 5.000, 4.750, 4.500        //3
	];
	/**
	Defines operator parameter numbers, within the unregistered namespace.
	*/
	public enum OperatorParamNums {
		//Unregistered
		Level		=	0,
		Attack		=	1,
		Decay		=	2,
		SusLevel	=	3,
		SusCtrl		=	4,
		Release		=	5,
		Waveform	=	6,
		Feedback	=	7,
		TuneCor		=	8,
		TuneFine	=	9,
		ShpA		=	10,
		ShpR		=	11,
		VelToLevel	=	12,
		MWToLevel	=	13,
		LFOToLevel	=	14,
		OpCtrl		=	15,
		VelToFB		=	16,
		MWToFB		=	17,
		LFOToFB		=	18,
		EEGToFB		=	19,
		VelToShpA	=	20,
		VelToShpR	=	21,
		KSLBegin	=	22,
		KSLAttenOut	=	23,
		KSLAttenFB	=	24,
		KSLAttenADSR=	25,
	}
	/**
	Defines channel parameter numbers, within the unregistered namespace.
	*/
	public enum ChannelParamNums {
		MasterVol	=	0,
		Bal			=	1,
		AuxSLA		=	2,
		AuxSLB		=	3,
		EEGDetune	=	4,
		PLFO		=	5,
		Attack		=	6,
		Decay		=	7,
		SusLevel	=	8,
		SusCtrl		=	9,
		Release		=	10,
		ShpA		=	11,
		ShpR		=	12,
		GlobalFB	=	13,
		ChCtrl		=	16,
		EEGToLeft	=	18,
		EEGToRight	=	19,
		EEGToAuxA	=	20,
		EEGToAuxB	=	21,
		LFOToLeft	=	22,
		LFOToRight	=	23,
		LFOToAuxA	=	24,
		LFOToAuxB	=	25,
		MWToGFB		=	26,
		VelToGFB	=	27,
	}
	/**
	Defines channel parameters within the registered namespace
	*/
	public enum ChannelRegParams {
		PitchBendSens,
		TuneCor,
		TuneFine,
	}
	/**
	Defines global parameter nummbers, within the unregistered namespace
	*/
	public enum GlobalParamNums {
		PLFORate	=	0,
		PLFOWF		=	1,
		ALFORate	=	2,
		ALFOWF		=	3,
		FilterLCFreq=	4,
		FilterLCQ	=	5,
		FilterRCFreq=	6,
		FilterRCQ	=	7,
		FilterACFreq=	8,
		FilterACQ	=	9,
		FilterBCFreq=	10,
		FilterBCQ	=	11,
	}
	enum TuneCtrlFlags : uint {
		FineTuneMidPoint	=	0x1_00_00_00,
		CorTuneMidPoint		=	36<<25,
		FineTuneTest		=	0x1_FF_FF_FF,
		CorTuneTest			=	0xFE_00_00_00,
	}
	///Defines control values
	enum OpCtrlFlags {
		WavetableSelect	=	127,		///Wavetable select flags
		FBMode			=	1 << 7,		///Feedback mode (L: After Envelop Generator, H: Before Envelop Generator)
		FBNeg			=	1 << 8,		///Feedback mode (L: Positive, H: Negative)
		MWNeg			=	1 << 9,		///Invert modulation wheel control
		VelNeg			=	1 << 10,	///Invert velocity control
		EGRelAdaptive	=	1 << 11,	///Adaptive release time based on current output level
		FixedPitch		=	1 << 12,	///Enables fixed pitch mode
		EasyTune		=	1 << 13,	///Enables easy tune mode
	}
	/**
	Implements a single operator.
	
	Contains an oscillator, an ADSR envelop generator, and locals.
	*/
	public struct Operator {
		///Local copy of operator preset data.
		Preset.Op		preset;
		///The envelop generator of the operator.
		ADSREnvelopGenerator	eg;
		///The current position of the oscillator, including fractions.
		uint			pos;	
		///The amount the oscillator must be stepped forward each cycle, including fractions.
		uint			step;	
		///Input register.
		///The amount which the oscillator will be offsetted.
		int				input;
		///Feedback register. Either out_0[n-1] or out[n-1] multiplied by feedback amount.
		///The amount which the oscillator will be offsetted.
		///Negative if inverted.
		int				feedback;
		///Output register.
		///Not affected by either level or EG
		///Might be used for ring modulation.
		int				output;
		///Output affected by EEG and level.
		///Either used for audible output, or to modulate other operators
		int				output_0;
		///Calculated output level containing KSL damping
		float			outL	=	0;
		///Calculated feedback level containing KSL damping
		float			fbL		=	0;
		///Live calculated out of shpA
		float			shpA0	=	0.0;
		///Live calculated out of shpR
		float			shpR0	=	0.0;

		///Sets the frequency of the operator
		///Also calculates KSL levels
		void setFrequency(int slmpFreq, ubyte note, double pitchBend, double tuning) @nogc @safe pure nothrow {
			double actualNote, oscFreq;
			if (preset.opCtrl & OpCtrlFlags.EasyTune) {
				double ratio;
				const int tuneAm = (preset.tune>>25) - (TuneCtrlFlags.CorTuneMidPoint>>25);
				switch (tuneAm) {
					case -36:
						ratio = 1/8;
						break;
					case -35: .. case -31:
						ratio = 1/6;
						break;
					case -30: .. case -28:
						ratio = 1/5;
						break;
					case -27: .. case -24:
						ratio = 1/4;
						break;
					case -23: .. case -18:
						ratio = 1/3;
						break;
					case -17: .. case -12:
						ratio = 1/2;
						break;
					case -11: .. case 6:
						ratio = 1;
						break;
					case 7: .. case 11:
						ratio = 1.5;
						break;
					case 12: .. case 18:
						ratio = 2;
						break;
					case 19: .. case 23:
						ratio = 3;
						break;
					case 24: .. case 27:
						ratio = 4;
						break;
					case 28: .. case 30:
						ratio = 5;
						break;
					case 31: .. case 33:
						ratio = 6;
						break;
					case 34, 35:
						ratio = 7;
						break;
					case 36, 37:
						ratio = 8;
						break;
					case 38, 39:
						ratio = 9;
						break;
					case 40, 41:
						ratio = 10;
						break;
					case 42:
						ratio = 11;
						break;
					case 43, 44:
						ratio = 12;
						break;
					case 45:
						ratio = 13;
						break;
					case 46:
						ratio = 14;
						break;
					case 47:
						ratio = 15;
						break;
					default:
						ratio = 16;
						break;
				}
				oscFreq = noteToFreq(note + pitchBend, tuning) * ratio;
			} else {
				const double tuneOffset = (cast(double)(preset.tune>>25) - (TuneCtrlFlags.CorTuneMidPoint>>25))  // Coarse tune amount
					+ (((cast(double)(preset.tune & TuneCtrlFlags.FineTuneTest)) - TuneCtrlFlags.FineTuneMidPoint) / // Fine tune amount
					TuneCtrlFlags.FineTuneMidPoint);
				if (preset.opCtrl & OpCtrlFlags.FixedPitch) {
					actualNote = tuneOffset + 36;
				} else {
					actualNote = note + pitchBend + tuneOffset;
				}
				oscFreq = noteToFreq(actualNote, tuning);
			}
			calculateKSL(note);
			const double cycLen = oscFreq / (slmpFreq / 1024.0);
			step = cast(uint)(cast(double)(1<<21) * cycLen);
		}
		///Calculates KSL values
		void calculateKSL(ubyte note) @nogc @safe pure nothrow {
			if (!(preset.opCtrl & OpCtrlFlags.FixedPitch) && preset.kslBegin < note) {
				const double octaves = (note - preset.kslBegin) / 12.0;
				outL = preset.outL * (1.0 - (octaves * ((preset.kslAttenOut / ubyte.max) * 0.75)));
				fbL = (preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1) * 
						preset.fbL * (1.0 - (octaves * ((preset.kslAttenFB / ubyte.max) * 0.75)));
			} else {
				outL = preset.outL;
				fbL = (preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1) * preset.fbL;
			}
		}
		///Sets the Envelop generator
		void setEG(int sampleRate, ubyte note, float vel = 1.0) @nogc @safe pure nothrow {
			const double timeAmount = (!(preset.opCtrl & OpCtrlFlags.FixedPitch) && preset.kslBegin < note) ?
					1 - ((note - preset.kslBegin) * (0.04 * (preset.kslAttenADSR / 255))) : 1;
			//Set attack phase
			if (preset.atk) {
				eg.attackRate = calculateRate(ADSR_TIME_TABLE[preset.atk] * timeAmount, sampleRate);
			} else {
				eg.attackRate = 1.0;
			}
			//Set decay phase
			if (preset.dec) {
				eg.decayRate = calculateRate(ADSR_TIME_TABLE[preset.dec] * 2 * timeAmount, sampleRate, 
						ADSREnvelopGenerator.maxOutput, eg.sustainLevel);
			} else {
				eg.decayRate = 1.0;
			}
			//Set sustain phase
			if (preset.susCC) {
				eg.isPercussive = false;
				if (preset.susCC == 64) {
					eg.sustainControl = 0.0;
				} else if (preset.susCC < 64) {
					eg.sustainControl =  
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[62 - (preset.susCC - 1)], sampleRate);
				} else {
					eg.sustainControl = -1.0 *
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[preset.susCC - 64], sampleRate);
				}
			} else {
				eg.isPercussive = true;
				eg.sustainControl = 0.0;
			}
			//Set release phase
			if (preset.rel) {
				eg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.rel] * 2, sampleRate, eg.sustainLevel);
			} else {
				eg.releaseRate = 1.0;
			}
			setShpVals(vel);
		}
		///Recalculates shape params.
		void setShpVals(float vel = 1.0) @nogc @safe pure nothrow {
			shpA0 = preset.shpA - (preset.shpA * preset.shpAVel) + (preset.shpA * preset.shpAVel * vel);
			shpR0 = preset.shpR - (preset.shpR * preset.shpRVel) + (preset.shpR * preset.shpRVel * vel);
		}
		///Sets the key to off on this channel. Also calculates adaptive release rates if needed.
		void keyOff(int sampleRate) @nogc @safe pure nothrow {
			eg.keyOff();
			if (preset.rel && (preset.opCtrl & OpCtrlFlags.EGRelAdaptive)) {
				eg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.rel] * 2, sampleRate, eg.sustainLevel);
			}
		}
	}
	///Defines channel control flags.
	enum ChCtrlFlags {
		///Channel combination turned off, the channel pair is independent
		ComboModeOff	=	0b0000,	
		///Channel combination mode 1: Secondary channel's output is fed into primary operator 0.
		ComboMode1		=	0b0001,
		///Channel combination mode 2: Secondary channel's output is fed into primary operator 1 if primary 
		///is in serial mode, or into both if primary is in parallel mode.
		ComboMode2		=	0b0010,
		///Channel combination mode 3: Secondary channel's output is fed into main output, except if primary 
		///channel set to parallel and secondary set to serial, then S1, P0, and P1 are connected to output, while
		///S0 is modulating all of them.
		ComboMode3		=	0b0011,
		///Used for testing combo mode.
		ComboModeTest	=	ComboMode3,
		Algorithm		=	1<<2,	///Channel algorithm (H: Parallel, L: Series)
		IndivOutChLev	=	1<<3,	///Enables the setting of individual output channel levels
		LFOPan			=	1<<4,	///Enables LFO Panning
		EEGPan			=	1<<5,	///Enables EEG Panning
		MWToTrem		=	1<<6,	///Assigns modwheel to amplitude LFO
		MWToVibr		=	1<<7,	///Assigns modwheel to pitch LFO
		MWToAux			=	1<<8,	///Assigns modwheel to aux levels
		ResetOnKeyOn	=	1<<9,	///Resets all operators and envelops belonging to this channel on key on event
		ResetMode		=	1<<10,	///If set, then reset only occurs of all envelops have reached `Off` state after a keyOff event
		FBMode			=	1<<11,	///Feedback mode (L: After Envelop Generator, H: Before Envelop Generator)
		FBNeg			=	1<<12,	///Feedback mode (L: Positive, H: Negative)
	}
	/**
	Defines channel common parameters.
	*/
	public struct Channel {
		///Copy of channel relevant preset data
		Preset.Ch		preset;
		///Extra envelop generator that can be assigned for multiple purpose.
		ADSREnvelopGenerator	eeg;
		///Calculated output level controls + aux send levels
		///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
		__m128			outLevels;
		///Sets the Extra Envelop generator
		void setEEG(int sampleRate) @nogc @safe pure nothrow {
			//Set attack phase
			if (preset.atkX) {
				eeg.attackRate = calculateRate(ADSR_TIME_TABLE[preset.atkX], sampleRate);
			} else {
				eeg.attackRate = 1.0;
			}
			//Set decay phase
			if (preset.decX) {
				eeg.decayRate = calculateRate(ADSR_TIME_TABLE[preset.decX] * 2, sampleRate, ADSREnvelopGenerator.maxOutput, 
						eeg.sustainLevel);
			} else {
				eeg.decayRate = 1.0;
			}
			//Set sustain phase
			if (preset.susCCX) {
				eeg.isPercussive = false;
				if (preset.susCCX == 64) {
					eeg.sustainControl = 0.0;
				} else if (preset.susCCX < 64) {
					eeg.sustainControl =  
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[62 - (preset.susCCX - 1)], sampleRate);
				} else {
					eeg.sustainControl = -1.0 *
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[preset.susCCX - 64], sampleRate);
				}
			} else {
				eeg.isPercussive = true;
				eeg.sustainControl = 0.0;
			}
			//Set release phase
			if (preset.relX) {
				eeg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.relX] * 2, sampleRate, eeg.sustainLevel);
			} else {
				eeg.releaseRate = 1.0;
			}
		}
		/** 
		 * Recalculates the output levels for the channel.
		 */
		void recalculateOutLevels() @nogc @safe pure nothrow {
			if (preset.chCtrl == ChCtrlFlags.IndivOutChLev) {
				outLevels[0] = preset.masterVol;
				outLevels[1] = preset.masterBal;
			} else {
				outLevels[0] = preset.masterVol * preset.masterBal;
				outLevels[1] = preset.masterVol * (1 - preset.masterBal);
			}
			outLevels[2] = preset.auxSendA;
			outLevels[3] = preset.auxSendB;
		}
	}
	/**
	Stores channel controller values (modwheel, velocity, etc.)
	*/
	public struct ChControllers {
		///Modulation wheel parameter, normalized between 0.0 and 1.0
		float			modwheel	=	0;
		///Velocity parameter, normalized between 0.0 and 1.0
		float			velocity	=	0;
		///Pitch bend parameter, with the amount of pitch shifting in semitones + fractions
		float			pitchBend	=	0;
		///The note that is currently being played
		ubyte			note;
	}
	/**
	Defines a preset.
	*/
	public struct Preset {
		///Defines parameters of a single operator
		public struct Op {
			///Operator tuning
			///Bit 31-25: Coarse detuning (-36 to +91 seminotes)
			///Bit 24-0: Fine detuning (-100 to 100 cents), 0x1_00_00_00 is center
			///If fixed mode is being used, then top 7 bits are the note, the rest are fine tuning.
			uint			tune	=	TuneCtrlFlags.CorTuneMidPoint | TuneCtrlFlags.FineTuneMidPoint;
			///Output level (between 0.0 and 1.0)
			float			outL	=	0.50;
			///Feedback level (between 0.0 and 1.0)
			float			fbL		=	0.0;
			///Control flags and Wavetable selector
			uint			opCtrl = OpCtrlFlags.EasyTune;
			///Output level controller assignment
			///Index notation: 0: velocity 1: modulation wheel 2: Amplitude LFO 3: unused
			__m128			outLCtrl=	[0,0,0,0];
			///Feedback level controller assignment
			///Index notation: 0: velocity 1: modulation wheel 2: Amplitude LFO 3: Extra envelop generator
			__m128			fbLCtrl	=	[0,0,0,0];
			///Attack time control (between 0 and 127)
			ubyte			atk;
			///Decay time control (between 0 and 127)
			ubyte			dec;
			///Release time control (between 0 and 127)
			ubyte			rel = 1;
			///Sustain curve control (between 0 and 127)
			///0: Percussive mode
			///1 - 63: Descending over time
			///64: Constant
			///65 - 127: Ascending over time
			ubyte			susCC = 64;
			///Sustain level for the EG
			float			susLevel=	1.0;
			///ADSR shaping parameter (for the attack phase)
			float			shpA	=	0.5;
			///ADSR shaping parameter (for the decay/release phase)
			float			shpR	=	0.5;
			///Assigns velocity to shpA
			float			shpAVel	=	0.0;
			///Assigns velocity to shpR
			float			shpRVel =	0.0;
			///Key Scale Level beginning point
			ubyte			kslBegin = ubyte.max;
			///Key Scale Level attenuation amount for output (0 = 0.0db/Oct ; 255 = 6.0db/Oct)
			ubyte			kslAttenOut;
			///Key Scale Level attenuation amount for feedback (0 = 0.0db/Oct ; 255 = 6.0db/Oct)
			ubyte			kslAttenFB;
			///Key Scale Level attenuation amount for attack/decay times (0 = 0%/Oct ; 255 = 4%/Oct)
			ubyte			kslAttenADSR;
		}
		///Defines parameters of a single channel.
		public struct Ch {
			///ADSR shaping parameter (for the attack phase)
			float			shpAX	=	0.5;
			///ADSR shaping parameter (for the decay/release phase)
			float			shpRX	=	0.5;
			///Pitch amount for EEG
			float			eegDetuneAm	=	0;
			///Pitch bend sensitivity
			///Up to +/-2 octaves
			float			pitchBendSens = 2;
			///A-4 channel tuning in hertz.
			float			chnlTun = 440.0;
			///Stores channel control flags.
			uint			chCtrl = ChCtrlFlags.ResetMode;
			///Master volume (0.0 to 1.0)
			float			masterVol=	1;
			///Master balance (0.0 to 1.0)
			float			masterBal=	0.5;//
			///Aux send A
			float			auxSendA=	0;
			///Aux send B
			float			auxSendB=	0;
			///Modwheel to global feedback
			float			mwToGFB	=	0;
			///Velocity to global feedback
			float			velToGFB=	0;//
			///EEG assign levels
			///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
			__m128			eegLevels=	[0,0,0,0];
			///Amplitude LFO assign levels
			///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
			__m128			aLFOlevels=	[0,0,0,0];
			///Global feedback
			///Only available on certain algorithms
			float			globalFb	=	0;
			///Pitch LFO level
			float			pLFOlevel	=	0;
			///Amplitude LFO to 
			///Attack time control (between 0 and 127)
			ubyte			atkX;
			///Decay time control (between 0 and 127)
			ubyte			decX;
			///Release time control (between 0 and 127)
			ubyte			relX;
			///Sustain curve control (between 0 and 127)
			///0: Percussive mode
			///1 - 63: Descending over time
			///64: Constant
			///65 - 127: Ascending over time
			ubyte			susCCX	=	64;
			///Sustain level
			float			susLevel	=	1;
		}
		Op[2]			operators;		///The operators belonging to this channel
		Ch				channel;		///Channel common values
	}
	///Contains the wavetables for the operators and LFOs.
	///Value might be divided to limit the values between 2047 and -2048 via bitshifting,
	///otherwise the full range can be used for audio output, etc.
	///Loaded from a 16 bit wave file.
	protected short[1024][128]	wavetables;
	///Stores presets.
	///8 banks of 128 presets are available for a total of 1024.
	///If a channel combination is being used, then bank pairs (0-1, 2-3, etc) will store their primary and secondary
	///halves, and calling either will load both halves.
	protected Preset[128][8]	soundBank;
	///Operator data.
	///See rendering function on updating.
	protected Operator[32]		operators;
	///Channel data.
	///See rendering function on updating.
	protected Channel[16]		channels;
	///Channel control data.
	protected ChControllers[16]	chCtrls;
	///Preset numbers per channels.
	protected ubyte[16]			presetNum;
	///Bank numbers per channels.
	protected ubyte[16]			bankNum;
	///Keeps the registered/unregistered parameter positions (LSB = 1).
	//protected ubyte[2]			paramNum;
	///Stores LFO waveform selection. 1: Amplitude; 0: Pitch
	protected ubyte[2]			lfoWaveform;
	///Stores temporary parameter values 
	///0: MSB of sel unregistered param 1: LSB of sel unregistered param 
	///2: MSB of sel registered param 3: LSB of sel registered param
	protected ubyte[4]			paramTemp;
	///Stores ALFO position
	protected uint				aLFOPos;
	///Stores ALFO rate
	protected uint				aLFORate;
	///Stores output filter values.
	///0: a0; 1: a1; 2: a2; 3: b0; 4: b1; 5: b2; 6: x[n-1]; 7: x[n-2]; 8: y[n-1] 9: y[n-2]
	protected __m128[10]		filterVals;
	///Stores control values of the output values.
	///Layout: [LF, LQ, RF, RQ, AF, AQ, BF, BQ]
	protected float[8]			filterCtrl	=	[16_000, 1, 16_000, 1, 16_000, 1, 16_000, 1];
	///Initial mixing buffers
	///Output is directed there before filtering
	///Layout is: LRAB
	protected float[]			initBuffers;
	///Dummy buffer
	///Only used if one or more outputs haven't been defined
	protected float[]			dummyBuf;
	///Amplitude LFO buffer. Values are between 0.0 and 1.0
	protected float[]			aLFOBuf;
	///Pitch LFO output. Values are between -1.0 and 1.0
	protected float				pLFOOut	=	0;
	///Stores PLFO position
	protected uint				pLFOPos;
	///Stores PLFO rate
	protected uint				pLFORate;
	///Mixdown value.
	///Used for final mixing.
	protected float				mixdownVal = short.max + 1;//4096;
	alias ChFun = void delegate(int chNum, size_t length) @nogc pure nothrow;
	///Channel update delegates
	protected ChFun[16]			chDeleg;
	///Used as a keepsake for MIDI 1.0 control change values.
	protected ubyte[64]			ccLow;
	/**
	Creates an instance of QM816
	*/
	public this() @trusted nothrow {
		info.nOfAudioInput = 0;
		info.nOfAudioOutput = 4;
		info.outputChNames = ["mainL", "mainR", "auxSendA", "auxSendB"];
		info.isInstrument = true;
		info.hasMidiIn = true;
		info.hasMidiOut = true;
		info.midiSendback = true;
		try {
			WaveFormat f = WaveFormat(0, 0, AudioFormat.PCM, 1, 0, 16);
			short[1024] buffer = generateSinewave([0x01, 0x09, 0x11, 0x19]);
			waveformDataReceive(0, reinterpretCast!ubyte(buffer), f);		///Sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x00]);
			waveformDataReceive(1, reinterpretCast!ubyte(buffer), f);		///Half-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x01, 0x09]);
			waveformDataReceive(2, reinterpretCast!ubyte(buffer), f);		///Full-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x00, 0x01, 0x00]);
			waveformDataReceive(3, reinterpretCast!ubyte(buffer), f);		///Pulse-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x11, 0x00]);
			waveformDataReceive(4, reinterpretCast!ubyte(buffer), f);		///Pulse-sine 75%
			buffer = generateSinewave([0x01, 0x00, 0x00, 0x00]);
			waveformDataReceive(5, reinterpretCast!ubyte(buffer), f);		///Pulse-sine 25%
			buffer = generateSinewave([0x01, 0x00, 0x11, 0x00]);
			waveformDataReceive(6, reinterpretCast!ubyte(buffer), f);		///Alternating pulse-sine
			buffer = generateSinewave([0x05, 0x00, 0x1d, 0x00]);
			waveformDataReceive(7, reinterpretCast!ubyte(buffer), f);		///Alternating sine (from OPL3)
			buffer = generateSinewave([0x05, 0x05, 0x1d, 0x1d]);
			waveformDataReceive(8, reinterpretCast!ubyte(buffer), f);		///Camel sine (from OPL3)
			buffer = generateSinewave([0x01, 0x09, 0x11, 0x1f]);
			waveformDataReceive(9, reinterpretCast!ubyte(buffer), f);		///Variant sine 0
			buffer = generateSinewave([0x01, 0x09, 0x1d, 0x1d]);
			waveformDataReceive(10, reinterpretCast!ubyte(buffer), f);		///Variant sine 1
			buffer = generateSinewave([0x01, 0x09, 0x0d, 0x0d]);
			waveformDataReceive(11, reinterpretCast!ubyte(buffer), f);		///Variant sine 2
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x1d]);
			waveformDataReceive(12, reinterpretCast!ubyte(buffer), f);		///Variant sine 3
			buffer = generateSinewave([0x01, 0x09, 0x1d, 0x00]);
			waveformDataReceive(13, reinterpretCast!ubyte(buffer), f);		///Variant sine 4
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x0d]);
			waveformDataReceive(14, reinterpretCast!ubyte(buffer), f);		///Variant sine 5
			buffer = generateSinewave([0x01, 0x09, 0x0d, 0x00]);
			waveformDataReceive(15, reinterpretCast!ubyte(buffer), f);		///Variant sine 6
			buffer = generateSinewave([0x01, 0x09, 0x1f, 0x1f]);
			waveformDataReceive(16, reinterpretCast!ubyte(buffer), f);		///Variant sine 7
			buffer = generatePulseWave(768);
			waveformDataReceive(17, reinterpretCast!ubyte(buffer), f);		///Pulse wave 75%
			buffer = generatePulseWave(512);
			waveformDataReceive(18, reinterpretCast!ubyte(buffer), f);		///Pulse wave 50%
			buffer = generatePulseWave(256);
			waveformDataReceive(19, reinterpretCast!ubyte(buffer), f);		///Pulse wave 25%
			buffer = generatePulseWave(128);
			waveformDataReceive(20, reinterpretCast!ubyte(buffer), f);		///Pulse wave 12.5%
			buffer = generatePulseWave(100);
			waveformDataReceive(21, reinterpretCast!ubyte(buffer), f);		///Pulse wave 10%
			buffer = generatePulseWave(50);
			waveformDataReceive(22, reinterpretCast!ubyte(buffer), f);		///Pulse wave 5%
			buffer = generateTriangularWave(1023);
			waveformDataReceive(23, reinterpretCast!ubyte(buffer), f);		///Ramp wave
			buffer = generateTriangularWave(768);
			waveformDataReceive(24, reinterpretCast!ubyte(buffer), f);		///Morphed ramp
			buffer = generateTriangularWave(512);
			waveformDataReceive(25, reinterpretCast!ubyte(buffer), f);		///Triangle wave
			buffer = generateTriangularWave(256);
			waveformDataReceive(26, reinterpretCast!ubyte(buffer), f);		///Morphed saw
			buffer = generateTriangularWave(2);
			waveformDataReceive(27, reinterpretCast!ubyte(buffer), f);		///Saw wave
		} catch (Exception e) {

		}
		//Reset delegates
		for (int i ; i < chDeleg.length ; i++) {
			chDeleg[i] = &updateChannelM00;
		}
	}
	/**
	 * Sets the module up.
	 *
	 * Can be overridden in child classes to allow resets.
	 */
	public override void moduleSetup(ubyte[] inputs, ubyte[] outputs, int sampleRate, size_t bufferSize, 
			ModuleManager handler) @safe nothrow {
		// void test() @trusted nothrow {
			// midiReceive(UMP(MessageType.MIDI2, 0x0, MIDI2_0Cmd.NoteOn, 0x0, 0x3f, 0x0));
		// }
		enabledInputs = StreamIDSet(inputs);
		enabledOutputs = StreamIDSet(outputs);
		this.sampleRate = sampleRate;
		this.bufferSize = bufferSize;
		this.handler = handler;
		//set up and reset buffers
		initBuffers.length = bufferSize * 4;
		resetBuffer(initBuffers);
		dummyBuf.length = bufferSize;
		resetBuffer(dummyBuf);
		aLFOBuf.length = bufferSize;
		resetBuffer(aLFOBuf);
		//Reset filters
		for (int i ; i < 4 ; i++) {
			BiquadFilterValues vals = createLPF(sampleRate, filterCtrl[i * 2], filterCtrl[(i * 2) + 1]);
			filterVals[0][i] = vals.a0;
			filterVals[1][i] = vals.a1;
			filterVals[2][i] = vals.a2;
			filterVals[3][i] = vals.b0;
			filterVals[4][i] = vals.b1;
			filterVals[5][i] = vals.b2;
			filterVals[6][i] = 0;
			filterVals[7][i] = 0;
			filterVals[8][i] = 0;
			filterVals[9][i] = 0;
		}
		//Reset operator EGs
		for (int i ; i < operators.length ; i++) {
			operators[i].setEG(sampleRate, 40);
		}
		//Reset channel EGs
		for (int i ; i < channels.length ; i++) {
			channels[i].setEEG(sampleRate);
			channels[i].recalculateOutLevels();
		}
		//test();
	}
	/**
	 * Receives waveform data that has been loaded from disk for reading. Returns zero if successful, or a specific 
	 * errorcode.
	 *
	 * id: The ID of the waveform.
	 * rawData: The data itself, in unprocessed form.
	 * format: The format of the wave data, including the data type, bit depth, base sampling rate
	 *
	 * Note: This function needs the audio system to be unlocked.
	 */
	public override int waveformDataReceive(uint id, ubyte[] rawData, WaveFormat format) nothrow {
		int errorcode;
		if (format.channels != 1) errorcode |= SampleLoadErrorCode.ChNumNotSupported;
		if (format.bitsPerSample != 16) errorcode |= SampleLoadErrorCode.BitdepthNotSupported;
		if (format.format != AudioFormat.PCM) errorcode |= SampleLoadErrorCode.FormatNotSupported;
		if (rawData.length != 128 * 1024 * 2 && rawData.length != 1024 * 2) 
			errorcode |= SampleLoadErrorCode.SampleLenghtNotSupported;
		if (errorcode) {
			return errorcode;
		} else {
			import core.stdc.string : memcpy;
			if (rawData.length == 128 * 1024 * 2)
				memcpy(wavetables.ptr, rawData.ptr, 128 * 1024 * 2);
			else
				memcpy(wavetables[id].ptr, rawData.ptr, 1024 * 2);
			return 0;
		}
	}
	/**
	 * MIDI 2.0 data received here.
	 *
	 * data0: Header of the up to 128 bit MIDI 2.0 data.
	 * data1-3: Other packets if needed.
	 */
	public override void midiReceive(UMP data0, uint data1 = 0, uint data2 = 0, uint data3 = 0) @nogc nothrow {
		//data0 = UMP(MessageType.MIDI2, 0x0, MIDI2_0Cmd.NoteOn, 0x0, 0x3f, 0x0);
		switch (data0.msgType) {
			case MessageType.SysCommMsg:	//Process system common message
				break;
			case MessageType.MIDI1:			//Process MIDI 1.0 messages
				switch (data0.status) {
					case MIDI1_0Cmd.CtrlCh:	//Process MIDI 1.0 control change messages
						switch (data0.note) {
							case 0, 32:			//Bank select
								bankNum[data0.channel] = data0.value & 7;
								break;
							case 1, 33:			//Modulation wheel
								ccLow[data0.note] = data0.value;
								chCtrls[data0.channel].modwheel = cast(double)((ccLow[1]<<7) + ccLow[33]) / (ushort.max>>2);
								break;
							case 6, 38:			//Data Entry
								ccLow[data0.note] = data0.value;
								paramTemp = [0xFF,0xFF,0xFF,0xFF];
								break;
							case 18, (32+18):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[18], ccLow[32+18]), [0, 0], data0.channel);
								break;
							case 19, (32+19):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[19], ccLow[32+19]), [1, 0], data0.channel);
								break;
							case 16, (32+16):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[16], ccLow[32+16]), [0, 3], data0.channel);
								break;
							case 17, (32+17):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[17], ccLow[32+17]), [1, 3], data0.channel);
								break;
							case 20, (32+20):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[20], ccLow[32+20]), [0, 10], data0.channel);
								break;
							case 22, (32+22):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[22], ccLow[32+22]), [1, 10], data0.channel);
								break;
							case 21, (32+21):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[21], ccLow[32+21]), [0, 10], data0.channel);
								break;
							case 23, (32+23):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[23], ccLow[32+23]), [1, 10], data0.channel);
								break;
							case 30, (32+30):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[30], ccLow[32+30]), [0, 9], data0.channel);
								break;
							case 31, (32+31):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[31], ccLow[32+31]), [1, 9], data0.channel);
								break;
//
							case 73:
								setUnregisteredParam(data0.value<<25, [1, 1], data0.channel);
								break;
							case 78:
								setUnregisteredParam(data0.value<<25, [0, 1], data0.channel);
								break;
							case 74:
								setUnregisteredParam(data0.value<<25, [1, 2], data0.channel);
								break;
							case 79:
								setUnregisteredParam(data0.value<<25, [0, 2], data0.channel);
								break;
							case 85:
								setUnregisteredParam(data0.value<<25, [0, 4], data0.channel);
								break;
							case 86:
								setUnregisteredParam(data0.value<<25, [1, 4], data0.channel);
								break;
							case 87:
								setUnregisteredParam(data0.value<<25, [0, 8], data0.channel);
								break;
							case 88:
								setUnregisteredParam(data0.value<<25, [1, 8], data0.channel);
								break;
							case 72:
								setUnregisteredParam(data0.value<<25, [1, 5], data0.channel);
								break;
							case 77:
								setUnregisteredParam(data0.value<<25, [0, 5], data0.channel);
								break;
							case 70:
								setUnregisteredParam(data0.value<<25, [1, 6], data0.channel);
								break;
							case 75:
								setUnregisteredParam(data0.value<<25, [0, 6], data0.channel);
								break;
							case 71:
								setUnregisteredParam(data0.value<<25, [1, 7], data0.channel);
								break;
							case 76:
								setUnregisteredParam(data0.value<<25, [0, 7], data0.channel);
								break;
//
							case 7, 32+7:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[7], ccLow[32+7]), [4, 0], data0.channel);
								break;
							case 8, 32+8:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[8], ccLow[32+8]), [4, 1], data0.channel);
								break;
							case 24, 32+24:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[24], ccLow[32+24]), [4, 11], data0.channel);
								break;
							case 25, 32+25:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[25], ccLow[32+25]), [4, 12], data0.channel);
								break;
//
							case 91:
								setUnregisteredParam(data0.value<<25, [4, 2], data0.channel);
								break;
							case 92:
								setUnregisteredParam(data0.value<<25, [4, 3], data0.channel);
								break;
							case 93:
								setUnregisteredParam(data0.value<<25, [4, 4], data0.channel);
								break;
							case 94:
								setUnregisteredParam(data0.value<<25, [4, 5], data0.channel);
								break;
							case 102:
								setUnregisteredParam(data0.value<<25, [4, 6], data0.channel);
								break;
							case 103:
								setUnregisteredParam(data0.value<<25, [4, 7], data0.channel);
								break;
							case 104:
								setUnregisteredParam(data0.value<<25, [4, 8], data0.channel);
								break;
							case 105:
								setUnregisteredParam(data0.value<<25, [4, 9], data0.channel);
								break;
							case 106:
								setUnregisteredParam(data0.value<<25, [4, 10], data0.channel);
								break;
							case 107:
								setUnregisteredParam(data0.value<<25, [4, 13], data0.channel);
								break;
//
							case 98:		//Non Registered Parameter Number MSB (handle through MIDI 2.0)
								paramTemp[0] = data0.value;
								if (paramTemp[0] != 0xFF)
									setUnregisteredParam(convertM1CtrlValToM2(paramTemp[0], paramTemp[1]), [ccLow[6], ccLow[38]], data0.channel);
								break;
							case 99:		//Non Registered Parameter Number LSB (handle through MIDI 2.0)
								//setUnregisteredParam(data0.value, paramNum, 0, data0.channel);
								paramTemp[1] = data0.value;
								if (paramTemp[0] != 0xFF)
									setUnregisteredParam(convertM1CtrlValToM2(paramTemp[0], paramTemp[1]), [ccLow[6], ccLow[38]], data0.channel);
								break;
							default:
								break;
						}
						break;
					case MIDI1_0Cmd.NoteOn:	//Note on command
						keyOn(data0.note, data0.channel, data0.value/127.0);
						break;
					case MIDI1_0Cmd.NoteOff://Note off command
						keyOff(data0.note, data0.channel, data0.value/127.0);
						break;
					case MIDI1_0Cmd.ChAftrTch:
						chCtrls[data0.channel].velocity = cast(double)data0.note / cast(double)byte.max;
						break;
					case MIDI1_0Cmd.PolyAftrTch:
						chCtrls[data0.channel].velocity = cast(double)data0.velocity / cast(double)byte.max;
						break;
					case MIDI1_0Cmd.PrgCh:	//Program change
						const uint chOffset = data0.channel;
						const uint chCtrl = soundBank[bankNum[chOffset] & 7][presetNum[chOffset]].channel.chCtrl;
						if (chCtrl & ChCtrlFlags.ComboModeTest) {
							const uint chX = chOffset & 7, bankX = bankNum[chOffset] & 7 & ~1;
							prgRecall(chX, presetNum[chX], bankX);
							prgRecall(chX + 8, presetNum[chX], bankX + 1);
						} else {
							prgRecall(chOffset, presetNum[chOffset], bankNum[chOffset]);
						}
						break;
					case MIDI1_0Cmd.PitchBend:
						const uint ch = data0.channel;
						/+const double pitchBendSens = (channels[ch].preset.pitchBendSens>>25) + 
								(cast(double)(channels[ch].preset.pitchBendSens & 0x01_FF_FF_FF) / 0x01_FF_FF_FF);+/
						chCtrls[ch].pitchBend = channels[ch].preset.pitchBendSens * ((cast(double)data0.bend - 0x20_00) / 0x3F_FF);
						break;
					default:
						assert(0, "MIDI 1.0 data error!");
						//break;
				}
				break;
			case MessageType.MIDI2:
				switch (data0.status) {
					case MIDI2_0Cmd.CtrlCh:	//Control change
						setUnregisteredParam(data1, [data0.index, data0.value], data0.channel);
						break;
					case MIDI2_0Cmd.CtrlChR://Registered control change
						//setRegisteredParam(data[1], [data0.index, data0.value], data0.channel);
						break;
					case MIDI2_0Cmd.PrgCh:	//Program change
						const uint chOffset = data0.channel;
						//const uint prg = data[1]>>24, bank = data[1] & 7;
						presetNum[chOffset] = cast(ubyte)(data1>>24);
						if (data0.value & 1) bankNum[chOffset] = cast(ubyte)(data1 & 7);
						const uint chCtrl = soundBank[bankNum[chOffset] & 7][presetNum[chOffset]].channel.chCtrl;
						if (chCtrl & ChCtrlFlags.ComboModeTest) {
							const uint chX = chOffset & 7, bankX = bankNum[chOffset] & 7 & ~1;
							prgRecall(chX, presetNum[chX], bankX);
							prgRecall(chX + 8, presetNum[chX], bankX + 1);
						} else {
							prgRecall(chOffset, presetNum[chOffset], bankNum[chOffset]);
						}
						break;
					case MIDI2_0Cmd.NoteOn:
						NoteVals v = *cast(NoteVals*)(&data1);
						keyOn(data0.note, data0.channel, v.velocity/65_535.0);
						break;
					case MIDI2_0Cmd.NoteOff:
						NoteVals v = *cast(NoteVals*)(&data1);
						keyOff(data0.note, data0.channel, v.velocity/65_535.0);
						break;
					case MIDI2_0Cmd.PitchBend:
						const uint ch = data0.channel;
						/+const double pitchBendSens = (channels[ch].preset.pitchBendSens>>25) + 
								(cast(double)(channels[ch].preset.pitchBendSens & 0x01_FF_FF_FF) / 0x01_FF_FF_FF);+/
						chCtrls[ch].pitchBend = channels[ch].preset.pitchBendSens * (cast(double)(data0.bend - (uint.max / 2)) / (uint.max / 2));
						break;
					default:
						assert(0, "MIDI 2.0 data error!");
						//break;
				}
				break;
			default:
				//assert(0, "Something went really wrong!");
				break;
		}
	}
	/** 
	 * Implements a key-on event.
	 * Params:
	 *   note = identifies which key is being pressed. Affects KSL control parameters
	 *   ch = channel number
	 *   vel = key velocity
	 *   bend = amount of initial bend (MIDI 2.0 only)
	 */
	protected void keyOn(ubyte note, ubyte ch, float vel, float bend = float.nan) @nogc pure nothrow {
		void hardReset() @safe @nogc pure nothrow {
			channels[ch].eeg.keyOn();
			operators[ch].eg.keyOn();
			operators[ch + 1].eg.keyOn();
			operators[ch].pos = 0;
			operators[ch + 1].pos = 0;
		}
		void softReset() @safe @nogc pure nothrow {
			channels[ch].eeg.keyOnNoReset();
			operators[ch].eg.keyOnNoReset();
			operators[ch + 1].eg.keyOnNoReset();
		}
		void hardResetCmb() @safe @nogc pure nothrow {
			channels[ch + 8].eeg.keyOn();
			operators[ch + 16].eg.keyOn();
			operators[ch + 17].eg.keyOn();
			operators[ch + 16].pos = 0;
			operators[ch + 17].pos = 0;
		}
		void softResetCmb() @safe @nogc pure nothrow {
			channels[ch + 8].eeg.keyOnNoReset();
			operators[ch + 16].eg.keyOnNoReset();
			operators[ch + 17].eg.keyOnNoReset();
		}
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch > 7) return;
		chCtrls[ch].note = note;
		chCtrls[ch].velocity = vel;
		if (!isNaN(bend)) chCtrls[ch].pitchBend = bend;
		operators[ch].setFrequency(sampleRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
		operators[ch].setEG(sampleRate, note, vel);
		operators[ch + 1].setFrequency(sampleRate, note, chCtrls[ch + 1].pitchBend, channels[ch].preset.chnlTun);
		operators[ch + 1].setEG(sampleRate, note, vel);
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch <= 7) {
			operators[ch + 16].setFrequency(sampleRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
			operators[ch + 16].setEG(sampleRate, note, vel);
			operators[ch + 17].setFrequency(sampleRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
			operators[ch + 17].setEG(sampleRate, note, vel);
			if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetOnKeyOn) {
				hardReset();
				hardResetCmb();
			} else if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetMode) {
				if ((channels[ch].eeg.position | channels[ch + 8].eeg.position | operators[ch].eg.position |
						operators[ch + 1].eg.position | operators[ch + 16].eg.position | operators[ch + 17].eg.position) == 
						ADSREnvelopGenerator.Stage.Off) {
					hardReset();
					hardResetCmb();
				} else {
					softReset();
					softResetCmb();
				}
			} else {
				softReset();
				softResetCmb();
			}
		} else {
			if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetOnKeyOn) {
				hardReset();
			} else if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetMode) {
				if ((channels[ch].eeg.position | operators[ch].eg.position | operators[ch + 1].eg.position) == 
						ADSREnvelopGenerator.Stage.Off) {
					hardReset();
				} else {
					softReset();
				}
			} else {
				softReset();
			}
		}
	}
	/** 
	 * Implements a key-off event.
	 * Params:
	 *   note = 
	 *   ch = 
	 *   vel = 
	 */
	protected void keyOff(ubyte note, ubyte ch, float vel, float bend = 0) @nogc pure nothrow {
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch > 7) return;
		chCtrls[ch].note = note;
		chCtrls[ch].velocity = vel;
		channels[ch].eeg.keyOff();
		operators[ch].keyOff(sampleRate);
		operators[ch + 1].keyOff(sampleRate);
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch <= 7) {
			channels[ch + 8].eeg.keyOff();
			operators[ch + 16].keyOff(sampleRate);
			operators[ch + 17].keyOff(sampleRate);
		}
	}
	/**
	Sets the channel delegates
	*/
	protected void setChDeleg(uint chCtrl, uint chNum, uint chCtrl0 = 0) @nogc @safe pure nothrow {
		if (chCtrl & ChCtrlFlags.ComboModeTest) {	//Test if channel is combined or not
			if (chNum < 8) {
				const uint algID = (chCtrl & (ChCtrlFlags.ComboModeTest | ChCtrlFlags.Algorithm)) | 
						((chCtrl0 & ChCtrlFlags.Algorithm)<<1);
				enum priChAlg = ChCtrlFlags.Algorithm;
				enum secChAlg = ChCtrlFlags.Algorithm<<1;
				switch (algID) {
					case ChCtrlFlags.ComboMode1:
						chDeleg[chNum] = &updateChannelM100;
						break;
					case ChCtrlFlags.ComboMode1 | secChAlg:
						chDeleg[chNum] = &updateChannelM110;
						break;
					case ChCtrlFlags.ComboMode1 | priChAlg:
						chDeleg[chNum] = &updateChannelM101;
						break;
					case ChCtrlFlags.ComboMode1 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM111;
						break;
					case ChCtrlFlags.ComboMode2:
						chDeleg[chNum] = &updateChannelM200;
						break;
					case ChCtrlFlags.ComboMode2 | secChAlg:
						chDeleg[chNum] = &updateChannelM210;
						break;
					case ChCtrlFlags.ComboMode2 | priChAlg:
						chDeleg[chNum] = &updateChannelM201;
						break;
					case ChCtrlFlags.ComboMode2 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM211;
						break;
					case ChCtrlFlags.ComboMode3:
						chDeleg[chNum] = &updateChannelM300;
						break;
					case ChCtrlFlags.ComboMode3 | secChAlg:
						chDeleg[chNum] = &updateChannelM310;
						break;
					case ChCtrlFlags.ComboMode3 | priChAlg:
						chDeleg[chNum] = &updateChannelM301;
						break;
					case ChCtrlFlags.ComboMode3 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM311;
						break;
					default:
						chDeleg[chNum] = &updateChannelMD;
						break;
				}
			} else {
				chDeleg[chNum] = &updateChannelMD;
			}
		} else {
			if (chCtrl & ChCtrlFlags.Algorithm) 
				chDeleg[chNum] = &updateChannelM01;
			else
				chDeleg[chNum] = &updateChannelM00;
		}
	}
	/**
	Recalls a program
	*/
	protected void prgRecall(ubyte ch, ubyte prg, ubyte bank) @nogc @safe pure nothrow {
		Preset p = soundBank[bank & 7][prg];
		operators[ch].preset = p.operators[0];
		operators[ch].setEG(sampleRate, 40);
		operators[ch + 1].preset = p.operators[1];
		operators[ch + 1].setEG(sampleRate, 40);
		channels[ch].preset = p.channel;
		channels[ch].setEEG(sampleRate);
	}
	/**
	Sets a registered parameter

	If type is not zero, then the MSB is being set, otherwise the LSB will be used
	*/
	protected void setRegisteredParam(T)(T val, ubyte[2] paramNum, ubyte type, ubyte chNum) @nogc @safe pure nothrow {
		switch (paramNum[0]) {
			case ChannelRegParams.PitchBendSens:
				static if (is(T == uint)) {
					channels[chNum].pitchBendSens = (cast(double)val / (uint.max / 127.0));
				} else static if (is(T == ubyte)) {
					const int whole = cast(int)(channels[chNum].pitchBendSens);
					if (type) {
						channels[chNum].pitchBendSens = whole + (val / byte.max);
					} else {
						channels[chNum].pitchBendSens = (channels[chNum].pitchBendSens - whole) * val;
					}
				}
				break;
			case ChannelRegParams.TuneFine:			//Channel master tuning (fine)
				break;
			case ChannelRegParams.TuneCor:			//Channel master tuning (coarse)
				break;
			default: break;
		}
	}
	/**
	Sets an unregistered parameter (MIDI 2.0)

	If type is not zero, then the MSB is being set, otherwise the LSB will be used
	*/
	protected void setUnregisteredParam(uint val, ubyte[2] paramNum, ubyte chNum) @nogc @safe pure nothrow {
		void setOpParam(int opNum) {
			switch (paramNum[0]) {
				case OperatorParamNums.Attack:
					operators[opNum].preset.atk = cast(ubyte)(val >> 25);
					operators[opNum].setEG(sampleRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.Decay:
					operators[opNum].preset.dec = cast(ubyte)(val >> 25);
					operators[opNum].setEG(sampleRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.Feedback:
					const double valF = cast(double)val / uint.max;
					operators[opNum].preset.fbL = pow(valF, 2.5) * (operators[opNum].preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1);
					break;
				case OperatorParamNums.Level:
					const double valF = cast(double)val / uint.max;
					operators[opNum].preset.outL = valF * valF;
					operators[opNum].calculateKSL(chCtrls[chNum].note);
					break;
				case OperatorParamNums.OpCtrl:
					operators[opNum].preset.opCtrl &= OpCtrlFlags.WavetableSelect;
					operators[opNum].preset.opCtrl |= val<<7;
					break;
				case OperatorParamNums.Release:
					operators[opNum].preset.rel = cast(ubyte)(val >> 25);
					operators[opNum].setEG(sampleRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.ShpA:
					operators[opNum].preset.shpA = cast(double)val / uint.max;
					operators[opNum].setShpVals(chCtrls[chNum].velocity);
					break;
				case OperatorParamNums.ShpR:
					operators[opNum].preset.shpR = cast(double)val / uint.max;
					operators[opNum].setShpVals(chCtrls[chNum].velocity);
					break;
				case OperatorParamNums.SusCtrl:
					operators[opNum].preset.susCC = cast(ubyte)(val >> 25);
					operators[opNum].setEG(sampleRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.SusLevel:
					operators[opNum].eg.sustainLevel = cast(double)val / uint.max;
					//Recalculate decay and release rates to new sustain levels
					if (operators[opNum].preset.dec) {
						operators[opNum].eg.decayRate = calculateRate(ADSR_TIME_TABLE[operators[opNum].preset.dec] * 2, sampleRate, 
								ADSREnvelopGenerator.maxOutput, operators[opNum].eg.sustainLevel);
					} else {
						operators[opNum].eg.decayRate = 1.0;
					}
					if (operators[opNum].preset.rel) {
						operators[opNum].eg.releaseRate = calculateRate(ADSR_TIME_TABLE[operators[opNum].preset.rel] * 2, sampleRate, 
								operators[opNum].eg.sustainLevel);
					} else {
						operators[opNum].eg.releaseRate = 1.0;
					}
					break;
				case OperatorParamNums.TuneCor:
					operators[opNum].preset.tune &= ~TuneCtrlFlags.CorTuneTest; 
					operators[opNum].preset.tune |= val & TuneCtrlFlags.CorTuneTest;
					
					break;
				case OperatorParamNums.TuneFine:
					operators[opNum].preset.tune &= ~uint.max>>7;
					operators[opNum].preset.tune |= val>>7;
					break;
				case OperatorParamNums.VelToLevel:
					operators[opNum].preset.outLCtrl[0] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.MWToLevel:
					operators[opNum].preset.outLCtrl[1] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.LFOToLevel:
					operators[opNum].preset.outLCtrl[2] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToFB:
					operators[opNum].preset.fbLCtrl[0] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.MWToFB:
					operators[opNum].preset.fbLCtrl[1] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.LFOToFB:
					operators[opNum].preset.fbLCtrl[2] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.EEGToFB:
					operators[opNum].preset.fbLCtrl[3] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToShpA:
					operators[opNum].preset.shpAVel = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToShpR:
					operators[opNum].preset.shpRVel = cast(double)val / uint.max;
					break;
				case OperatorParamNums.Waveform:
					operators[opNum].preset.opCtrl &= ~OpCtrlFlags.WavetableSelect;
					operators[opNum].preset.opCtrl |= cast(ubyte)(val >> 25);
					break;
				case OperatorParamNums.KSLBegin:
					const ubyte newval = cast(ubyte)(val>>25);
					if (newval == 127)
						operators[opNum].preset.kslBegin = ubyte.max;
					else
						operators[opNum].preset.kslBegin = newval;
					break;
				case OperatorParamNums.KSLAttenOut:
					operators[opNum].preset.kslAttenOut = cast(ubyte)(val>>24);
					break;
				case OperatorParamNums.KSLAttenFB:
					operators[opNum].preset.kslAttenFB = cast(ubyte)(val>>24);
					break;
				case OperatorParamNums.KSLAttenADSR:
					operators[opNum].preset.kslAttenADSR = cast(ubyte)(val>>24);
					break;
				default: break;
			}
		}
		void setOpFlag(int opNum){
			if (val) 
				operators[opNum].preset.opCtrl |= 1<<(paramNum[0] + 7);
			else
				operators[opNum].preset.opCtrl &= ~(1<<(paramNum[0] + 7));
		}
		switch (paramNum[1]) {
			case 0:			//Channel operator 0
				//chNum *= 2;
				setOpParam(chNum * 2);
				break;
			case 1:			//Channel operator 1
				//chNum *= 2;
				setOpParam((chNum * 2) + 1);
				break;
			case 2:			//Channel operator 0 flags
				setOpFlag(chNum * 2);
				break;
			case 3:			//Channel operator 1 flags
				setOpFlag((chNum * 2) + 1);
				break;
			case 4:			//Channel common values
				switch (paramNum[0]) { 
					//case ChannelParamNums.ALFO: break;
					case ChannelParamNums.Attack:
						channels[chNum].preset.atkX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.atkX) {
							channels[chNum].eeg.attackRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.atkX], sampleRate);
						} else {
							channels[chNum].eeg.attackRate = 1.0;
						}
						break;
					case ChannelParamNums.AuxSLA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						channels[chNum].preset.auxSendA = channels[chNum].outLevels[2];
						break;
					case ChannelParamNums.AuxSLB: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						channels[chNum].preset.auxSendB = channels[chNum].outLevels[3];
						break;
					case ChannelParamNums.Bal: 
						channels[chNum].preset.masterBal = cast(double)val / uint.max;
						if (channels[chNum].preset.chCtrl & ChCtrlFlags.IndivOutChLev) {
							channels[chNum].outLevels[1] = channels[chNum].preset.masterBal * channels[chNum].preset.masterBal;
						} else {
							channels[chNum].outLevels[0] = channels[chNum].preset.masterVol - channels[chNum].preset.masterBal;
							channels[chNum].outLevels[1] = channels[chNum].preset.masterVol - (1.0 - channels[chNum].preset.masterBal);
						}
						break;
					case ChannelParamNums.ChCtrl:
						channels[chNum].preset.chCtrl = val;
						//mirror operator configuration parameters between paired channels
						if (chNum < 8) {
							channels[chNum + 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
							channels[chNum + 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
						} else {
							channels[chNum - 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
							channels[chNum - 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
						}
						break;
					//case ChannelParamNums.ChCtrlL: break;
					case ChannelParamNums.Decay:
						channels[chNum].preset.decX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.decX) {
							channels[chNum].eeg.decayRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.decX] * 2, sampleRate);
						} else {
							channels[chNum].eeg.decayRate = 1.0;
						}
						break;
					case ChannelParamNums.EEGDetune:
						channels[chNum].preset.eegDetuneAm = ((cast(double)(uint.max>>1) - cast(double)val) / (uint.max>>1)) * 24;
						break;
					case ChannelParamNums.MasterVol: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						if (channels[chNum].preset.chCtrl & ChCtrlFlags.IndivOutChLev) {
							channels[chNum].outLevels[1] = channels[chNum].preset.masterBal * channels[chNum].preset.masterBal;
						} else {
							channels[chNum].outLevels[0] = channels[chNum].preset.masterVol - channels[chNum].preset.masterBal;
							channels[chNum].outLevels[1] = channels[chNum].preset.masterVol - (1.0 - channels[chNum].preset.masterBal);
						}
						break;
					case ChannelParamNums.PLFO: 
						channels[chNum].preset.pLFOlevel = cast(double)val / uint.max;
						break;
					case ChannelParamNums.Release: 
						channels[chNum].preset.relX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.relX) {
							channels[chNum].eeg.releaseRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.relX] * 2, sampleRate);
						} else {
							channels[chNum].eeg.releaseRate = 1.0;
						}
						break;
					case ChannelParamNums.ShpA:
						channels[chNum].preset.shpAX = cast(double)val / uint.max;
						break;
					case ChannelParamNums.ShpR:
						channels[chNum].preset.shpRX = cast(double)val / uint.max;
						break;
					case ChannelParamNums.SusCtrl: 
						channels[chNum].preset.susCCX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.susCCX) {
							channels[chNum].eeg.isPercussive = false;
							if (channels[chNum].preset.susCCX == 64) {
								channels[chNum].eeg.sustainControl = 0.0;
							} else if (channels[chNum].preset.susCCX < 64) {
								channels[chNum].eeg.sustainControl = -1.0 * 
										calculateRate(SUSTAIN_CONTROL_TIME_TABLE[channels[chNum].preset.susCCX - 1], sampleRate);
							} else {
								channels[chNum].eeg.sustainControl = 
										calculateRate(SUSTAIN_CONTROL_TIME_TABLE[channels[chNum].preset.susCCX - 64], sampleRate);
							}
						} else {
							channels[chNum].eeg.isPercussive = true;
							channels[chNum].eeg.sustainControl = 0.0;
						}
						break;
					case ChannelParamNums.SusLevel: 
						channels[chNum].eeg.sustainLevel = cast(double)val / uint.max;
						channels[chNum].preset.susLevel = channels[chNum].eeg.sustainLevel;
						break;
					case ChannelParamNums.GlobalFB: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.globalFb = valF * valF;
						break;
					case ChannelParamNums.EEGToLeft:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[0] = valF * valF;
						break;
					case ChannelParamNums.EEGToRight:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[1] = valF * valF;
						break;
					case ChannelParamNums.EEGToAuxA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[2] = valF * valF;
						break;
					case ChannelParamNums.EEGToAuxB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[3] = valF * valF;
						break;
					case ChannelParamNums.LFOToLeft:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[0] = valF * valF;
						break;
					case ChannelParamNums.LFOToRight:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[1] = valF * valF;
						break;
					case ChannelParamNums.LFOToAuxA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[2] = valF * valF;
						break;
					case ChannelParamNums.LFOToAuxB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[3] = valF * valF;
						break;
					case ChannelParamNums.MWToGFB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.mwToGFB = valF;
						break;
					case ChannelParamNums.VelToGFB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.velToGFB = valF;
						break;
					default:
						break;
				}
				break;
			case 5:		//Channel common flags
				if (val)
					channels[chNum].preset.chCtrl |= 1<<paramNum[0];
				else
					channels[chNum].preset.chCtrl &= ~(1<<paramNum[0]);
				if (chNum < 8) {
					channels[chNum + 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
					channels[chNum + 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
					setChDeleg(channels[chNum].preset.chCtrl, chNum, channels[chNum + 8].preset.chCtrl);
					setChDeleg(channels[chNum + 8].preset.chCtrl, chNum + 8);
				} else {
					channels[chNum - 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
					channels[chNum - 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
					setChDeleg(channels[chNum - 8].preset.chCtrl, chNum - 8, channels[chNum].preset.chCtrl);
					setChDeleg(channels[chNum].preset.chCtrl, chNum);
				}
				break;
			case 16:		//LFO and master filter settings
				void setFilterFreq(int num) @nogc @safe pure nothrow {
					const double valF = cast(double)val / uint.max;
					filterCtrl[num] = valF * valF * 20_000;

				}
				void setFilterQ(int num) @nogc @safe pure nothrow {
					const double valF = cast(double)val / uint.max;
					filterCtrl[num] = valF * 2;
				}
				switch (paramNum[0]) {
					case GlobalParamNums.PLFORate:
						double valF;
						valF = cast(double)val / uint.max;
						valF *= 16;
						const double cycleLen = sampleRate / (1.0 / valF);
						pLFORate = cast(int)(cycleLen * ((1<<20) / 1024.0) * bufferSize);
						break;
					case GlobalParamNums.PLFOWF:
						lfoWaveform[0] = cast(ubyte)(val >> 25);
						break;
					case GlobalParamNums.ALFORate:
						double valF;
						valF = cast(double)val / uint.max;
						valF *= 16;
						const double cycleLen = sampleRate / (1.0 / valF);
						aLFORate = cast(int)(cycleLen * ((1<<20) / 1024.0));
						break;
					case GlobalParamNums.ALFOWF:
						lfoWaveform[1] = cast(ubyte)(val >> 25);
						break;
					case GlobalParamNums.FilterLCFreq:
						setFilterFreq(0);
						break;
					case GlobalParamNums.FilterLCQ: 
						setFilterQ(1);
						break;
					case GlobalParamNums.FilterRCFreq: 
						setFilterFreq(2);
						break;
					case GlobalParamNums.FilterRCQ: 
						setFilterQ(3);
						break;
					case GlobalParamNums.FilterACFreq:
						setFilterFreq(4);
						break;
					case GlobalParamNums.FilterACQ: 
						setFilterQ(5);
						break;
					case GlobalParamNums.FilterBCFreq: 
						setFilterFreq(6);
						break;
					case GlobalParamNums.FilterBCQ: 
						setFilterQ(7);
						break;
					default:
						break;
				}
				break;
			default: break;
		}
	}
	/**
	 * Renders the current audio frame.
	 * 
	 * input: the input buffers if any, null if none.
	 * output: the output buffers if any, null if none.
	 *
	 * NOTE: Buffers must have matching sizes.
	 */
	public override void renderFrame(float*[] input, float*[] output) @nogc nothrow {
		//Generate aLFO table
		for (int i ; i < bufferSize ; i++) {
			aLFOBuf[i] = (wavetables[lfoWaveform[1]][(aLFOPos>>20) & 1023] - short.min) * (1 / cast(float)(ushort.max));
			aLFOPos += aLFORate;
		}
		//Generate pLFO out
		{
			pLFOOut = (wavetables[lfoWaveform[0]][(pLFOPos>>20) & 1023]) * (1 / cast(float)(short.max));
			pLFOPos += pLFORate;
		}
		//Render each channel
		foreach (size_t i, ChFun fun ; chDeleg) {
			
			fun(cast(int)i, bufferSize);
		}
		//chDeleg[0](0, bufferSize);
		//Filter and mix outputs
		float*[4] outBuf;
		for (ubyte i, j ; i < 4 ; i++) {
			if (enabledOutputs.has(i)) {
				outBuf[i] = output[j];
				j++;
			} else {
				outBuf[i] = dummyBuf.ptr;
			}
		}
		const __m128 b0_a0 = filterVals[3] / filterVals[0], b1_a0 = filterVals[4] / filterVals[0], 
				b2_a0 = filterVals[5] / filterVals[0], a1_a0 = filterVals[1] / filterVals[0], a2_a0 = filterVals[2] / filterVals[0];
		for (int i ; i < bufferSize ; i++) {
			__m128 input0 = _mm_load_ps(initBuffers.ptr + (i * 4));
			input0 /= __m128(mixdownVal);
			input0 = _mm_max_ps(input0, __m128(-1.0));
			input0 = _mm_min_ps(input0, __m128(1.0));
			__m128 output0 = b0_a0 * input0 + b1_a0 * filterVals[6] + b2_a0 * filterVals[7] - a1_a0 * filterVals[8] - 
					a2_a0 * filterVals[9];
			for (int j ; j < 4 ; j++)
				outBuf[j][i] += output0[j];
			//	outBuf[j][i] += input0[j];
			filterVals[7] = filterVals[6];
			filterVals[6] = input0;
			filterVals[9] = filterVals[8];
			filterVals[8] = output0;
		}
		resetBuffer(initBuffers);
	}
	///Updates an operator for a cycle
	///chCtrl index notation: 0: velocity, 1: modulation wheel, 2: Amplitude LFO, 3: Extra Envelop Generator
	pragma(inline, true)
	protected final void updateOperator(ref Operator op, __m128 chCtrl) @nogc @safe pure nothrow {
		/+op.output = wavetables
				[op.preset.opCtrl & OpCtrlFlags.WavetableSelect][((op.pos>>21) + (op.input>>2) + (op.feedback>>3)) & 1023];+/
		op.output = wavetables
				[op.preset.opCtrl & OpCtrlFlags.WavetableSelect][(op.pos + (op.input<<19) + (op.feedback<<17))>>21 & 1023];
		const double egOut = op.eg.shp(op.eg.position == ADSREnvelopGenerator.Stage.Attack ? op.shpA0 : op.shpR0);
		const double out0 = op.output;
		__m128 outCtrl = (op.preset.outLCtrl * chCtrl) + (__m128(1.0) - op.preset.outLCtrl);
		__m128 fbCtrl = (op.preset.fbLCtrl * chCtrl) + (__m128(1.0) - op.preset.fbLCtrl);
		const double out1 = out0 * egOut;
		
		op.feedback = cast(int)((op.preset.opCtrl & OpCtrlFlags.FBMode ? out0 : out1) * op.fbL * fbCtrl[0] * 
				fbCtrl[1] * fbCtrl[2] * fbCtrl[3]);
		
		op.output_0 = cast(int)(out1 * op.outL * outCtrl[0] * outCtrl[1] * outCtrl[2]);
		op.pos += op.step;
		//op.input = 0;
		op.eg.advance();
	}
	///Updates automatic and manual pitchbend values (channel-assignable envelop, LFO, pitchbend CTRL) for 2 operators.
	pragma(inline, true)
	protected final void updatePitchbend2Op(ref Operator op0, ref Operator op1, ref Channel ch, ref ChControllers chCtrl) 
			@nogc @safe pure nothrow {
		if (!isClose(ch.preset.eegDetuneAm, 0.0, 0.1) || !isClose(ch.preset.pLFOlevel, 0.0, 0.01)
				|| !isClose(chCtrl.pitchBend, 0.0, 0.01)) {
			const float eegOut = ch.eeg.shp(ch.eeg.position == ADSREnvelopGenerator.Stage.Attack ? 
					ch.preset.shpAX : ch.preset.shpRX);
			const float vibrAm = pLFOOut * ch.preset.pLFOlevel * 
					(ch.preset.chCtrl & ChCtrlFlags.MWToVibr ? chCtrl.pitchBend : 1.0);
			op0.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op1.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
		}
	}
	///Updates automatic and manual pitchbend values (channel-assignable envelop, LFO, pitchbend CTRL) for 4 operators.
	pragma(inline, true)
	protected final void updatePitchbend4Op(ref Operator op0, ref Operator op1, ref Operator op2, ref Operator op3, 
			ref Channel ch, ref ChControllers chCtrl) @nogc @safe pure nothrow {
		if (!isClose(ch.preset.eegDetuneAm, 0.0, 0.1) || !isClose(ch.preset.pLFOlevel, 0.0, 0.01)
				|| !isClose(chCtrl.pitchBend, 0.0, 0.01)) {
			const float eegOut = ch.eeg.shp(ch.eeg.position == ADSREnvelopGenerator.Stage.Attack ? 
					ch.preset.shpAX : ch.preset.shpRX);
			const float vibrAm = pLFOOut * ch.preset.pLFOlevel * 
					(ch.preset.chCtrl & ChCtrlFlags.MWToVibr ? chCtrl.pitchBend : 1.0);
			op0.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op1.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op2.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op3.setFrequency(sampleRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
		}
	}
	///Macro for channel update constants that need to be calculated once per frame
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS =
		q{
			const int opOffset = chNum * 2;
			__m128 aLFOOutMW = __m128(channels[chNum].preset.chCtrl & ChCtrlFlags.MWToTrem ? 
					chCtrls[chNum].modwheel : 1.0);
			const float auxSendAmMW = (channels[chNum].preset.chCtrl & ChCtrlFlags.MWToAux ? 
					chCtrls[chNum].modwheel : 1.0);
			__m128 opCtrl0, opCtrl1, mwAuxCtrl;
			opCtrl0[0] = operators[opOffset].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl1[0] = operators[opOffset + 1].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl0[1] = operators[opOffset].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - chCtrls[chNum].modwheel : 
					chCtrls[chNum].modwheel;
			opCtrl1[1] = operators[opOffset + 1].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - chCtrls[chNum].modwheel : 
					chCtrls[chNum].modwheel;
			mwAuxCtrl[0] = 1.0;
			mwAuxCtrl[1] = 1.0;
			mwAuxCtrl[2] = auxSendAmMW;
			mwAuxCtrl[3] = auxSendAmMW;
			const float lfopan = (channels[chNum].preset.chCtrl & ChCtrlFlags.LFOPan ? 1.0 : 0);
			const float eegpan = (channels[chNum].preset.chCtrl & ChCtrlFlags.EEGPan ? 1.0 : 0);
		};
	///Macro for channel update constants that need to be calculated once per frame, for combined channels' second half
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS0 =
		q{
			__m128 opCtrl2, opCtrl3;
			opCtrl2[0] = operators[opOffset + 16].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl3[0] = operators[opOffset + 17].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl2[1] = operators[opOffset + 16].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - chCtrls[chNum].modwheel : 
					chCtrls[chNum].modwheel;
			opCtrl3[1] = operators[opOffset + 17].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - chCtrls[chNum].modwheel : 
					chCtrls[chNum].modwheel;
			const float eegpan0 = (channels[chNum + 8].preset.chCtrl & ChCtrlFlags.EEGPan ? 1.0 : 0);
		};
	///Macro for channel update constants that need to be calculated for each cycle
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS_CYCL = 
		q{
			const float eegOut = channels[chNum].eeg.shp(channels[chNum].eeg.position == 
					ADSREnvelopGenerator.Stage.Attack ? channels[chNum].preset.shpAX : channels[chNum].preset.shpRX);
			__m128 eegToMast = __m128(eegOut), lfoToMast = __m128(aLFOBuf[i]);
			eegToMast[0] = abs(eegpan - eegToMast[0]);
			lfoToMast[0] = abs(lfopan - lfoToMast[0]);
			opCtrl0[2] = aLFOBuf[i];
			opCtrl1[2] = aLFOBuf[i];
			opCtrl0[3] = eegOut;
			opCtrl1[3] = eegOut;
		};
	
	///Macro for channel update constants that need to be calculated for each cycle for combined channels' second half
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS_CYCL0 = 
		q{
			const float eegOut0 = channels[chNum + 8].eeg.shp(channels[chNum + 8].eeg.position == 
					ADSREnvelopGenerator.Stage.Attack ? channels[chNum + 8].preset.shpAX : 
					channels[chNum + 8].preset.shpRX);
			__m128 eegToMast0 = __m128(eegOut0);
			eegToMast0[0] = abs(eegpan0 - eegToMast0[0]);
			opCtrl2[2] = aLFOBuf[i];
			opCtrl3[2] = aLFOBuf[i];
			opCtrl2[3] = eegOut0;
			opCtrl3[3] = eegOut0;
		};
			
	///Macro for output mixing
	static immutable string CHNL_UPDATE_MIX =
		q{
			__m128 outlevels = channels[chNum].outLevels * mwAuxCtrl;
			outlevels *= (channels[chNum].preset.eegLevels * eegToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].preset.eegLevels));
			outlevels *= (channels[chNum].preset.aLFOlevels * lfoToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].preset.aLFOlevels));
			_mm_store1_ps(initBuffers.ptr + (i<<2), _mm_load_ps(initBuffers.ptr + (i<<2)) + outlevels *
					_mm_cvtepi32_ps(outSum));
		};
	///Macro for output mixing in case of combo modes
	static immutable string CHNL_UPDATE_MIX0 =
		q{
			__m128 outlevels = channels[chNum].outLevels * mwAuxCtrl;
			outlevels *= (channels[chNum].eegLevels * eegToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].eegLevels));
			outlevels *= (channels[chNum + 8].eegLevels * eegToMast0) + (__m128(1.0) - 
			 (__m128(1.0) * channels[chNum + 8].eegLevels));
			outlevels *= (channels[chNum].aLFOlevels * lfoToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].aLFOlevels);
			_mm_store1_ps(initBuffers.ptr + (i<<2), _mm_load_ps(initBuffers.ptr + (i<<2)) + outlevels *
					_mm_cvtepi32_ps(outSum));
		};
	

	///Algorithm Mode 0/0 (Serial)
	protected void updateChannelM00(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		updatePitchbend2Op(operators[opOffset], operators[opOffset + 1], channels[chNum], chCtrls[chNum]);
		for (size_t i ; i < length ; i++) {
			channels[chNum].eeg.advance();
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			updateOperator(operators[opOffset], opCtrl0);
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);
			operators[opOffset].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
		}
	}
	///Algorithm Mode0/1 (Parallel)
	protected void updateChannelM01(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		updatePitchbend2Op(operators[opOffset], operators[opOffset + 1], channels[chNum], chCtrls[chNum]);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			updateOperator(operators[opOffset], opCtrl0);
			updateOperator(operators[opOffset + 1], opCtrl1);
			//const int outSum = operators[opOffset].output_0 + operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
		}
	}
	///Algorithm Mode1/00 ([S0]->[S1]->[P0]->[P1])
	protected void updateChannelM100(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);

		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	///Dummy algorithm for combined channels
	protected void updateChannelMD(int chNum, size_t length) @nogc pure nothrow {

	}
	/**
	Algorithm Mode1/10
	[S0]\
    	 ->[P0]->[P1]->
	[S1]/
	*/
	protected void updateChannelM110(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode1/01
	[S0]->[S1]->[P0]->
            	[P1]->
	*/
	protected void updateChannelM101(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode1/11
	[S0]\
    	 ->[P0]->
	[S1]/  [P1]->
	*/
	protected void updateChannelM111(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/00
	[S0]->[S1]\
	           ->[P1]->
    	  [P0]/
	*/
	protected void updateChannelM200(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0 + operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/10
	[S0]\
	[S1]-->[P1]->
	[P0]/
	*/
	protected void updateChannelM210(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0 + operators[opOffset + 17].output_0 + 
					operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/01
	          /[P0]->
	[S0]->[S1]
    	      \[P1]->
	*/
	protected void updateChannelM201(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/11
	[S0]\ /[P0]->
	     -
	[S1]/ \[P1]->
	*/
	protected void updateChannelM211(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/00
	[S0]->[S1]->
	[P0]->[P1]->
	*/
	protected void updateChannelM300(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 17].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset + 17].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/10
	      [S0]->
    	  [S1]->
	[P0]->[P1]->
	*/
	protected void updateChannelM310(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset + 17].output_0 + 
					operators[opOffset + 16].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/01
	    />[S1]->
	[S0]->[P0]->
    	\>[P1]->
	*/
	protected void updateChannelM301(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 17].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0 + 
					operators[opOffset + 17].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/11
	[S0]->
	[S1]->
	[P0]->
	[P1]->
	*/
	protected void updateChannelM311(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset].output_0 +
					operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}

	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int recallParam_int(uint presetID, uint paramID, int value) nothrow {
		return 0;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int recallParam_uint(uint presetID, uint paramID, uint value) nothrow {
		return 0;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int recallParam_double(uint presetID, uint paramID, double value) nothrow {
		return 0;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int recallParam_string(uint presetID, uint paramID, string value) nothrow {
		return 0;
	}
}
