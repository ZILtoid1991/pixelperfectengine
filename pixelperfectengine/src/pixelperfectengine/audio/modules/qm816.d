module pixelperfectengine.audio.modules.qm816;

import pixelperfectengine.audio.base.modulebase;
import pixelperfectengine.audio.base.envgen;
import pixelperfectengine.audio.base.func;

import pixelperfectengine.system.etc : hashCalc;

import midi2.types.structs;
import midi2.types.enums;

import inteli.emmintrin;

import bitleveld.reinterpret;

import std.math;

/**
QM816 - implements a Quadrature-Amplitude synthesizer. This technique was used in early 
digital FM synths, since it allowed allowed a cheap implementation of the same thing as
long as the modulator was a sinusoidal waveform.

It has 16 2 operator channels that can be individually paired-up for 4 operator channels,
for more complex sounds. Also all operators have the option for feedback, including 
carriers. 2 operator channels have 2, 4 operator channels have 3*4 algorithms.

The audio module generates a few default waveforms upon startup, but further ones can be
supplied from files, or generated by code. Some waveform generation code is already
supplied with the synth's code.
*/
public class QM816 : AudioModule {
	shared static this() {
		
		for (int i ; i < 128 ; i++) {
			ADSR_TIME_TABLE[i] = pow(i / 64.0, 1.8);
		}
	}
	/**
	Generates a waveform from a sinewave fragment (quarter).

	q flags:
	bit 0 = If set, then the sine fragment is present. If not, this portion will be replaced with all zeros instead.
	bit 1-2 = Doubling mode:
		0 = No doubling.
		1 = Same cycle twice.
		2 = Same cycle mirrored, effectively putting a half-sine into a quarter with the right settings.
		3 = The second half is all zeros, the sine fragment is effectively "stuffed" into an eight of the waveform.
	bit 3 = Horizontal mirroring of the cycle.
	bit 4 = Vertical mirroring of the cycle.
	bit 5 = Modifies the curve of the sinewave for a bit more square-ish shape.
	*/
	public static short[1024] generateSinewave(ubyte[4] q) @nogc @safe pure nothrow {
		short sineWave(int i, bool shape) @nogc @safe pure nothrow {
			real val = sin((PI_2 / 256) * i);
			if (shape) {
				if (val > 0) return cast(short)(sqrt(val) * short.max);
				else if (val < 0) return cast(short)(sqrt(val * -1) * short.max * -1);
				else return 0;
			} else return cast(short)(val * short.max);
		}
		short[1024] result;
		for (int j ; j < 4 ; j++) {
			if (q[j] & 1) {
				const int offset = 256 * j;
				const int hMir = q[j] & 0x8 ? 256 : 0;
				//int hBegin = q[j] & 0x8 ? 255 : 0;
				//const int vOffset = q[j] & 0x10 ? -1 : 0;
				const int vMir = q[j] & 0x10 ? 512 : 0;
				const bool shape = q[j] & 0x20 ? true : false;
				//const short[256] fragment = SINEWAVE_FRAGMENT;
				switch (q[j]>>1 & 3) {
					case 1:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						break;
					case 2:
						for (int i ; i < 128 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						for (int i ; i < 128 ; i++) {
							result[offset + i + 128] = sineWave((((127 - i) * 2) & 255) + hMir + vMir, shape);
						}
						break;
					case 3:
						for (int i ; i < 128 ; i++) {
							result[offset + i] = sineWave(((i * 2) & 255) + hMir + vMir, shape);
						}
						break;
					default:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = sineWave(i + hMir + vMir, shape);
						}
						break;
				}
				/+const int offset = 256 * j;
				int hMir = q[j] & 0x8 ? -1 : 1;
				int hBegin = q[j] & 0x8 ? 255 : 0;
				const int vOffset = q[j] & 0x10 ? -1 : 0;
				const int vMir = q[j] & 0x10 ? -1 : 1;
				const short[256] fragment = SINEWAVE_FRAGMENT;
				switch (q[j]>>1 & 3) {
					case 1:
						hMir *= 2;
						for (int i ; i < 256 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					case 2:
						hMir *= 2;
						for (int i ; i < 128 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						hMir *= -1;
						hBegin = q[j] & 0x8 ? 0 : 255;
						for (int i ; i < 128 ; i++) {
							result[offset + i + 128] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					case 3:
						hMir *= 2;
						for (int i ; i < 128 ; i++) {
							result[offset + i] = cast(short)(fragment[(hBegin + hMir * i) & 255] * vMir + vOffset);
						}
						break;
					default:
						for (int i ; i < 256 ; i++) {
							result[offset + i] = cast(short)(fragment[hBegin + hMir * i] * vMir + vOffset);
						}
						break;
				}+/
			}
		}
		return result;
	}	
	/**
	Generates a pulse wave.

	`width` controls the pulse width.
	*/
	public static short[1024] generatePulseWave(int width = 512) @nogc @safe pure nothrow {
		short[1024] result;
		for (int i ; i < 1024 ; i++) {
			result[i] = i < width ? short.max : short.min;
		}
		return result;
	}
	/**
	Generates a triangular waveform.
	`shape` controls the shape of the triangular waveform, allowing it to be morphed between triangle, saw, and ramp.
	``
	*/
	public static short[1024] generateTriangularWave(int shape = 512) @nogc @safe pure nothrow {
		import pixelperfectengine.system.etc : clamp;
		short[1024] result;
		int state;
		const int upwardSlope = ushort.max / shape;
		const int downwardSlope = ushort.max / (1024 - shape);
		for (int i ; i < shape / 2 ; i++) {
			state += upwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		for (int i = shape / 2 ; i < (shape / 2) + (1024 - shape) ; i++) {
			state -= downwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		for (int i = (shape / 2) + (1024 - shape) ; i < 1024 ; i++) {
			state += upwardSlope;
			clamp(state, short.min, short.max);
			result[i] = cast(short)state;
		}
		return result;
	}
	/** 
	Contains a table to calculate Attack, Decay, and Release values.

	All values are seconds with factions. Actual values are live-calculated depending on sustain-level and sampling
	frequency.

	Current formula for the ADSR time table:

	yn = (x/64)^1.8
	*/
	public static immutable float[128] ADSR_TIME_TABLE;
	/**
	Contains a table to calculate Sustain control values.

	All values are seconds with fractions. Actual values are live-calculated depending on sustain level and sampling
	frequency. Please note that with certain levels of sustain, the actual max time might be altered.
	*/
	public static immutable float[63] SUSTAIN_CONTROL_TIME_TABLE = [
	//	0     |1     |2     |3     |4     |5     |6     |7     |8     |9     |A     |B     |C     |D     |E     |F
		70.00, 60.00, 55.00, 50.00, 45.00, 42.50, 40.00, 38.50, 35.00, 32.50, 30.00, 27.50, 25.00, 24.00, 23.00, 22.00,//0
		21.00, 20.00, 19.00, 18.00, 17.50, 17.00, 16.50, 16.00, 15.50, 15.00, 14.50, 14.00, 13.50, 13.00, 12.50, 12.25,//1
		12.00, 11.75, 11.50, 11.25, 11.00, 10.75, 10.50, 10.25, 10.00, 9.750, 9.500, 9.250, 9.000, 8.750, 8.500, 8.250,//2
		8.000, 7.750, 7.500, 7.250, 7.000, 6.750, 6.500, 6.250, 6.000, 5.750, 5.500, 5.250, 5.000, 4.750, 4.500        //3
	];
	/**
	Used for quick resampling of the 55.5/60kHz output to 44.4/48kHz.

	So far this has the best results.
	*/
	public static immutable __m128[2][4] RESAMPLING_TABLE = [
		[__m128([1.00, 1.00, 1.00, 1.00]), __m128([0.00, 0.00, 0.00, 0.00])],
		[__m128([0.75, 0.75, 0.75, 0.75]), __m128([0.25, 0.25, 0.25, 0.25])],
		[__m128([0.50, 0.50, 0.50, 0.50]), __m128([0.50, 0.50, 0.50, 0.50])],
		[__m128([0.25, 0.25, 0.25, 0.25]), __m128([0.75, 0.75, 0.75, 0.75])],
	];
	/**
	Defines operator parameter numbers, within the unregistered namespace.
	*/
	public enum OperatorParamNums {
		//Unregistered
		Level		=	0,
		Attack		=	1,
		Decay		=	2,
		SusLevel	=	3,
		SusCtrl		=	4,
		Release		=	5,
		Waveform	=	6,
		Feedback	=	7,
		TuneCor		=	8,
		TuneFine	=	9,
		ShpA		=	10,
		ShpR		=	11,
		VelToLevel	=	12,
		MWToLevel	=	13,
		LFOToLevel	=	14,
		OpCtrl		=	15,
		VelToFB		=	16,
		MWToFB		=	17,
		LFOToFB		=	18,
		EEGToFB		=	19,
		VelToShpA	=	20,
		VelToShpR	=	21,
		KSLBegin	=	22,
		KSLAttenOut	=	23,
		KSLAttenFB	=	24,
		KSLAttenADSR=	25,
	}
	/**
	Defines channel parameter numbers, within the unregistered namespace.
	*/
	public enum ChannelParamNums {
		MasterVol	=	0,
		Bal			=	1,
		AuxSLA		=	2,
		AuxSLB		=	3,
		EEGDetune	=	4,
		PLFO		=	5,
		Attack		=	6,
		Decay		=	7,
		SusLevel	=	8,
		SusCtrl		=	9,
		Release		=	10,
		ShpA		=	11,
		ShpR		=	12,
		GlobalFB	=	13,
		ChCtrl		=	16,
		EEGToLeft	=	18,
		EEGToRight	=	19,
		EEGToAuxA	=	20,
		EEGToAuxB	=	21,
		LFOToLeft	=	22,
		LFOToRight	=	23,
		LFOToAuxA	=	24,
		LFOToAuxB	=	25,
		MWToGFB		=	26,
		VelToGFB	=	27,
	}
	/**
	Defines channel parameters within the registered namespace
	*/
	public enum ChannelRegParams {
		PitchBendSens,
		TuneCor,
		TuneFine,
	}
	/**
	Defines global parameter nummbers, within the unregistered namespace
	*/
	public enum GlobalParamNums {
		PLFORate	=	0,
		PLFOWF		=	1,
		ALFORate	=	2,
		ALFOWF		=	3,
		FilterLCFreq=	4,
		FilterLCQ	=	5,
		FilterRCFreq=	6,
		FilterRCQ	=	7,
		FilterACFreq=	8,
		FilterACQ	=	9,
		FilterBCFreq=	10,
		FilterBCQ	=	11,
		HPFLCFreq	=	12,
		HPFLCQ		=	13,
		HPFRCFreq	=	14,
		HPFRCQ		=	15,
		HPFACFreq	=	16,
		HPFACQ		=	17,
		HPFBCFreq	=	18,
		HPFBCQ		=	19,
		RingMod		=	20,
	}
	enum TuneCtrlFlags : uint {
		FineTuneMidPoint	=	0x1_00_00_00,
		CorTuneMidPoint		=	36<<25,
		FineTuneTest		=	0x1_FF_FF_FF,
		CorTuneTest			=	0xFE_00_00_00,
	}
	///Defines control values
	enum OpCtrlFlags {
		WavetableSelect	=	127,		///Wavetable select flags
		FBMode			=	1 << 7,		///Feedback mode (L: After Envelop Generator, H: Before Envelop Generator)
		FBNeg			=	1 << 8,		///Feedback mode (L: Positive, H: Negative)
		MWNeg			=	1 << 9,		///Invert modulation wheel control
		VelNeg			=	1 << 10,	///Invert velocity control
		EGRelAdaptive	=	1 << 11,	///Adaptive release time based on current output level
		FixedPitch		=	1 << 12,	///Enables fixed pitch mode
		EasyTune		=	1 << 13,	///Enables easy tune mode
		ContiTune		=	1 << 14,	///Enables continuous tuning through the coarsetune parameter
		ExprToMW		=	1 << 15,	///Switches modwheel to auxilliary control on this operator
	}
	/**
	Implements a single operator.
	
	Contains an oscillator, an ADSR envelop generator, and locals.
	*/
	public struct Operator {
		///Local copy of operator preset data.
		Preset.Op		preset;
		///The envelop generator of the operator.
		ADSREnvelopGenerator	eg;
		///The current position of the oscillator, including fractions.
		uint			pos;	
		///The amount the oscillator must be stepped forward each cycle, including fractions.
		uint			step;	
		///Input register.
		///The amount which the oscillator will be offsetted.
		int				input;
		///Feedback register. Either out_0[n-1] or out[n-1] multiplied by feedback amount.
		///The amount which the oscillator will be offsetted.
		///Negative if inverted.
		int				feedback;
		///Output register.
		///Not affected by either level or EG
		///Might be used for ring modulation.
		int				output;
		///Output affected by EEG and level.
		///Either used for audible output, or to modulate other operators
		int				output_0;
		///Calculated output level containing KSL damping
		float			outL	=	0;
		///Calculated feedback level containing KSL damping
		float			fbL		=	0;
		///Live calculated out of shpA
		float			shpA0	=	0.0;
		///Live calculated out of shpR
		float			shpR0	=	0.0;

		///Sets the frequency of the operator
		///Also calculates KSL levels
		void setFrequency(int slmpFreq, ubyte note, double pitchBend, double tuning) @nogc @safe pure nothrow {
			double actualNote, oscFreq;
			const int tuneAm = preset.opCtrl>>>25;//const int tuneAm = (preset.opCtrl>>>25) - 36;
			if (preset.opCtrl & OpCtrlFlags.EasyTune) {
				double ratio;
				switch (tuneAm) {
					case 0:
						ratio = 1.0/8;
						break;
					case 1: .. case 5:
						ratio = 1.0/6;
						break;
					case 6: .. case 8:
						ratio = 1.0/5;
						break;
					case 9: .. case 12:
						ratio = 1.0/4;
						break;
					case 13: .. case 18:
						ratio = 1.0/3;
						break;
					case 19: .. case 24:
						ratio = 1.0/2;
						break;
					case 25: .. case 42:
						ratio = 1;
						break;
					case 43: .. case 47:
						ratio = 1.5;
						break;
					case 48: .. case 54:
						ratio = 2;
						break;
					case 55: .. case 59:
						ratio = 3;
						break;
					case 60: .. case 63:
						ratio = 4;
						break;
					case 64: .. case 66:
						ratio = 5;
						break;
					case 67: .. case 69:
						ratio = 6;
						break;
					case 70, 71:
						ratio = 7;
						break;
					case 72, 73:
						ratio = 8;
						break;
					case 74, 75:
						ratio = 9;
						break;
					case 76, 77:
						ratio = 10;
						break;
					case 78:
						ratio = 11;
						break;
					case 79, 80:
						ratio = 12;
						break;
					case 81:
						ratio = 13;
						break;
					case 82:
						ratio = 14;
						break;
					case 83:
						ratio = 15;
						break;
					default:
						ratio = 16;
						break;
				}
				oscFreq = noteToFreq(note + pitchBend, tuning) * ratio;
			} else if (preset.opCtrl & OpCtrlFlags.ContiTune) {
				if (preset.opCtrl & OpCtrlFlags.FixedPitch) {
					actualNote = preset.tune;
				} else {
					actualNote = note + pitchBend + preset.tune;
				}
				oscFreq = noteToFreq(actualNote, tuning);
			} else {
				const double tuneOffset = tuneAm + preset.tune;
				if (!(preset.opCtrl & OpCtrlFlags.FixedPitch)) {
					actualNote = note + pitchBend + tuneOffset;
				}
				oscFreq = noteToFreq(actualNote, tuning);
			}
			calculateKSL(note);
			const double cycLen = oscFreq / ((slmpFreq + 1) / 1024.0);
			//step = cast(uint)(cast(double)(1<<21) * cycLen);
			step = cast(uint)(cast(double)(1<<22) * cycLen);
		}
		///Calculates KSL values
		void calculateKSL(ubyte note) @nogc @safe pure nothrow {
			if (!(preset.opCtrl & OpCtrlFlags.FixedPitch) && preset.kslBegin < note) {
				const double octaves = (note - preset.kslBegin) / 12.0;
				outL = preset.outL * (1.0 - (octaves * ((preset.kslAttenOut / ubyte.max) * 0.75)));
				fbL = (preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1) * 
						preset.fbL * (1.0 - (octaves * ((preset.kslAttenFB / ubyte.max) * 0.75)));
			} else {
				outL = preset.outL;
				fbL = (preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1) * preset.fbL;
			}
		}
		///Sets the Envelop generator
		void setEG(int sampleRate, ubyte note, float vel = 1.0) @nogc @safe pure nothrow {
			const double timeAmount = (!(preset.opCtrl & OpCtrlFlags.FixedPitch) && preset.kslBegin < note) ?
					1 - ((note - preset.kslBegin) * (0.1 * (preset.kslAttenADSR / 255))) : 1;
			//Set attack phase
			if (preset.atk) {
				eg.attackRate = calculateRate(ADSR_TIME_TABLE[preset.atk] * timeAmount, sampleRate);
			} else {
				eg.attackRate = 1.0;
			}
			//Set decay phase
			if (preset.dec) {
				eg.decayRate = calculateRate(ADSR_TIME_TABLE[preset.dec] * 2 * timeAmount, sampleRate, 
						ADSREnvelopGenerator.maxOutput, eg.sustainLevel);
			} else {
				eg.decayRate = 1.0;
			}
			//Set sustain phase
			if (preset.susCC) {
				eg.isPercussive = false;
				if (preset.susCC == 64) {
					eg.sustainControl = 0.0;
				} else if (preset.susCC < 64) {
					eg.sustainControl =  
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[62 - (preset.susCC - 1)], sampleRate);
				} else {
					eg.sustainControl = -1.0 *
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[preset.susCC - 64], sampleRate);
				}
			} else {
				eg.isPercussive = true;
				eg.sustainControl = 0.0;
			}
			//Set release phase
			if (preset.rel) {
				eg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.rel] * 2, sampleRate, eg.sustainLevel);
			} else {
				eg.releaseRate = 1.0;
			}
			setShpVals(vel);
		}
		///Recalculates shape params.
		void setShpVals(float vel = 1.0) @nogc @safe pure nothrow {
			shpA0 = preset.shpA - (preset.shpA * preset.shpAVel) + (preset.shpA * preset.shpAVel * vel);
			shpR0 = preset.shpR - (preset.shpR * preset.shpRVel) + (preset.shpR * preset.shpRVel * vel);
		}
		///Sets the key to off on this channel. Also calculates adaptive release rates if needed.
		void keyOff(int sampleRate) @nogc @safe pure nothrow {
			eg.keyOff();
			if (preset.rel && (preset.opCtrl & OpCtrlFlags.EGRelAdaptive)) {
				eg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.rel] * 2, sampleRate, eg.sustainLevel);
			}
		}
	}
	///Defines channel control flags.
	enum ChCtrlFlags {
		///Channel combination turned off, the channel pair is independent
		ComboModeOff	=	0b0000,	
		///Channel combination mode 1: Secondary channel's output is fed into primary operator 0.
		ComboMode1		=	0b0001,
		///Channel combination mode 2: Secondary channel's output is fed into primary operator 1 if primary 
		///is in serial mode, or into both if primary is in parallel mode.
		ComboMode2		=	0b0010,
		///Channel combination mode 3: Secondary channel's output is fed into main output, except if primary 
		///channel set to parallel and secondary set to serial, then S1, P0, and P1 are connected to output, while
		///S0 is modulating all of them.
		ComboMode3		=	0b0011,
		///Used for testing combo mode.
		ComboModeTest	=	ComboMode3,
		Algorithm		=	1<<2,	///Channel algorithm (H: Parallel, L: Series)
		IndivOutChLev	=	1<<3,	///Enables the setting of individual output channel levels
		LFOPan			=	1<<4,	///Enables LFO Panning
		EEGPan			=	1<<5,	///Enables EEG Panning
		MWToTrem		=	1<<6,	///Assigns modwheel to amplitude LFO
		MWToVibr		=	1<<7,	///Assigns modwheel to pitch LFO
		MWToAux			=	1<<8,	///Assigns modwheel to aux levels
		ResetOnKeyOn	=	1<<9,	///Resets all operators and envelops belonging to this channel on key on event
		ResetMode		=	1<<10,	///If set, then reset only occurs of all envelops have reached `Off` state after a keyOff event
		FBMode			=	1<<11,	///Feedback mode (L: After Envelop Generator, H: Before Envelop Generator)
		FBNeg			=	1<<12,	///Feedback mode (L: Positive, H: Negative)
	}
	/**
	Defines channel common parameters.
	*/
	public struct Channel {
		///Copy of channel relevant preset data
		Preset.Ch		preset;
		///Extra envelop generator that can be assigned for multiple purpose.
		ADSREnvelopGenerator	eeg;
		///Calculated output level controls + aux send levels
		///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
		__m128			outLevels;
		///Sets the Extra Envelop generator
		void setEEG(int sampleRate) @nogc @safe pure nothrow {
			//Set attack phase
			if (preset.atkX) {
				eeg.attackRate = calculateRate(ADSR_TIME_TABLE[preset.atkX], sampleRate);
			} else {
				eeg.attackRate = 1.0;
			}
			//Set decay phase
			if (preset.decX) {
				eeg.decayRate = calculateRate(ADSR_TIME_TABLE[preset.decX] * 2, sampleRate, ADSREnvelopGenerator.maxOutput, 
						eeg.sustainLevel);
			} else {
				eeg.decayRate = 1.0;
			}
			//Set sustain phase
			if (preset.susCCX) {
				eeg.isPercussive = false;
				if (preset.susCCX == 64) {
					eeg.sustainControl = 0.0;
				} else if (preset.susCCX < 64) {
					eeg.sustainControl =  
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[62 - (preset.susCCX - 1)], sampleRate);
				} else {
					eeg.sustainControl = -1.0 *
							calculateRate(SUSTAIN_CONTROL_TIME_TABLE[preset.susCCX - 64], sampleRate);
				}
			} else {
				eeg.isPercussive = true;
				eeg.sustainControl = 0.0;
			}
			//Set release phase
			if (preset.relX) {
				eeg.releaseRate = calculateRate(ADSR_TIME_TABLE[preset.relX] * 2, sampleRate, eeg.sustainLevel);
			} else {
				eeg.releaseRate = 1.0;
			}
		}
		/** 
		 * Recalculates the output levels for the channel.
		 */
		void recalculateOutLevels() @nogc @safe pure nothrow {
			if (preset.chCtrl == ChCtrlFlags.IndivOutChLev) {
				outLevels[0] = preset.masterVol;
				outLevels[1] = preset.masterBal;
			} else {
				outLevels[0] = preset.masterVol * preset.masterBal;
				outLevels[1] = preset.masterVol * (1 - preset.masterBal);
			}
			outLevels[2] = preset.auxSendA;
			outLevels[3] = preset.auxSendB;
		}
	}
	/**
	Stores channel controller values (modwheel, velocity, etc.)
	*/
	public struct ChControllers {
		///Modulation wheel parameter, normalized between 0.0 and 1.0
		float			modwheel	=	0;
		///Auxilliary controller parameter, normalized between 0.0 and 1.0
		float			auxCtrl		=	0;
		///Velocity parameter, normalized between 0.0 and 1.0
		float			velocity	=	0;
		///Pitch bend parameter, with the amount of pitch shifting in semitones + fractions
		float			pitchBend	=	0;
		///The note that is currently being played
		ubyte			note;
	}
	/**
	Defines a preset.
	*/
	public struct Preset {
		///Defines parameters of a single operator
		public struct Op {
			/+ ///Operator tuning
			///Bit 31-25: Coarse detuning (-36 to +91 seminotes)
			///Bit 24-0: Fine detuning (-100 to 100 cents), 0x1_00_00_00 is center
			///If fixed mode is being used, then top 7 bits are the note, the rest are fine tuning.
			uint			tune	=	TuneCtrlFlags.CorTuneMidPoint | TuneCtrlFlags.FineTuneMidPoint;+/
			///Sets the fine detuning or the whole tuning of the operator depending on tuning mode.
			float			tune	=	0.0;
			///Output level (between 0.0 and 1.0)
			float			outL	=	0.50;
			///Feedback level (between 0.0 and 1.0)
			float			fbL		=	0.0;
			///Control flags and Wavetable selector
			uint			opCtrl = OpCtrlFlags.EasyTune | TuneCtrlFlags.CorTuneMidPoint;
			///Output level controller assignment
			///Index notation: 0: velocity 1: modulation wheel 2: Amplitude LFO 3: unused
			__m128			outLCtrl=	[0,0,0,0];
			///Feedback level controller assignment
			///Index notation: 0: velocity 1: modulation wheel 2: Amplitude LFO 3: Extra envelop generator
			__m128			fbLCtrl	=	[0,0,0,0];
			///Attack time control (between 0 and 127)
			ubyte			atk;
			///Decay time control (between 0 and 127)
			ubyte			dec;
			///Release time control (between 0 and 127)
			ubyte			rel = 1;
			///Sustain curve control (between 0 and 127)
			///0: Percussive mode
			///1 - 63: Descending over time
			///64: Constant
			///65 - 127: Ascending over time
			ubyte			susCC = 64;
			///Sustain level for the EG
			float			susLevel=	1.0;
			///ADSR shaping parameter (for the attack phase)
			float			shpA	=	0.5;
			///ADSR shaping parameter (for the decay/release phase)
			float			shpR	=	0.5;
			///Assigns velocity to shpA
			float			shpAVel	=	0.0;
			///Assigns velocity to shpR
			float			shpRVel =	0.0;
			///Key Scale Level beginning point
			ubyte			kslBegin = ubyte.max;
			///Key Scale Level attenuation amount for output (0 = 0.0db/Oct ; 255 = 6.0db/Oct)
			ubyte			kslAttenOut;
			///Key Scale Level attenuation amount for feedback (0 = 0.0db/Oct ; 255 = 6.0db/Oct)
			ubyte			kslAttenFB;
			///Key Scale Level attenuation amount for attack/decay times (0 = 0%/Oct ; 255 = 10%/Oct)
			ubyte			kslAttenADSR;
		}
		///Defines parameters of a single channel.
		public struct Ch {
			///ADSR shaping parameter (for the attack phase)
			float			shpAX	=	0.5;
			///ADSR shaping parameter (for the decay/release phase)
			float			shpRX	=	0.5;
			///Pitch amount for EEG
			float			eegDetuneAm	=	0;
			///Pitch bend sensitivity
			///Up to +/-2 octaves
			float			pitchBendSens = 2;
			///A-4 channel tuning in hertz.
			float			chnlTun = 440.0;
			///Stores channel control flags.
			uint			chCtrl = ChCtrlFlags.ResetMode;
			///Master volume (0.0 to 1.0)
			float			masterVol=	1;
			///Master balance (0.0 to 1.0)
			float			masterBal=	0.5;//
			///Aux send A
			float			auxSendA=	0;
			///Aux send B
			float			auxSendB=	0;
			///Modwheel to global feedback
			float			mwToGFB	=	0;
			///Velocity to global feedback
			float			velToGFB=	0;//
			///EEG assign levels
			///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
			__m128			eegLevels=	[0,0,0,0];
			///Amplitude LFO assign levels
			///Index notation: 0: Left channel 1: Right channel 2: Aux send A, 3: Aux send B
			__m128			aLFOlevels=	[0,0,0,0];
			///Global feedback
			///Only available on certain algorithms
			float			globalFb	=	0;
			///Pitch LFO level
			float			pLFOlevel	=	0;
			///Amplitude LFO to 
			///Attack time control (between 0 and 127)
			ubyte			atkX;
			///Decay time control (between 0 and 127)
			ubyte			decX;
			///Release time control (between 0 and 127)
			ubyte			relX;
			///Sustain curve control (between 0 and 127)
			///0: Percussive mode
			///1 - 63: Descending over time
			///64: Constant
			///65 - 127: Ascending over time
			ubyte			susCCX	=	64;
			///Sustain level
			float			susLevel	=	1;
		}
		Op[2]			operators;		///The operators belonging to this channel
		Ch				channel;		///Channel common values
	}
	///Contains the wavetables for the operators and LFOs.
	///Value might be divided to limit the values between 2047 and -2048 via bitshifting,
	///otherwise the full range can be used for audio output, etc.
	///Loaded from a 16 bit wave file.
	protected short[1024][128]	wavetables;
	///Stores presets.
	///8 banks of 128 presets are available for a total of 1024.
	///If a channel combination is being used, then bank pairs (0-1, 2-3, etc) will store their primary and secondary
	///halves, and calling either will load both halves.
	protected Preset[128][8]	soundBank;
	///Operator data.
	///See rendering function on updating.
	protected Operator[32]		operators;
	///Channel data.
	///See rendering function on updating.
	protected Channel[16]		channels;
	///Channel control data.
	protected ChControllers[16]	chCtrls;
	///Preset numbers per channels.
	protected ubyte[16]			presetNum;
	///Bank numbers per channels.
	protected ubyte[16]			bankNum;
	///Keeps the registered/unregistered parameter positions (LSB = 1).
	//protected ubyte[2]			paramNum;
	///Stores LFO waveform selection. 0: Pitch; 1: Amplitude/Ringmod (if bit 7 is set)
	protected ubyte[2]			lfoWaveform;
	///Stores temporary parameter values 
	///0: MSB of sel unregistered param 1: LSB of sel unregistered param 
	///2: MSB of sel registered param 3: LSB of sel registered param
	protected ubyte[4]			paramTemp;
	///Stores ALFO position
	protected uint				aLFOPos;
	///Stores ALFO rate
	protected uint				aLFORate;
	///ALFO filter y[n-1]
	protected float				aLFO_y1;
	///ALFO filter factor 0 to 1
	protected float				aLFOff	=	1;
	///ALFO frequency
	protected float				aLFOFreq = 6;
	///Stores output filter values.
	///0: a0; 1: a1; 2: a2; 3: b0; 4: b1; 5: b2; 6: x[n-1]; 7: x[n-2]; 8: y[n-1] 9: y[n-2]
	protected __m128[10]		filterVals;
	///Stores control values of the output values.
	///Layout: [LF, LQ, RF, RQ, AF, AQ, BF, BQ]
	protected float[8]			filterCtrl	=	[16_000, 0.707, 16_000, 0.707, 16_000, 0.707, 16_000, 0.707];
	///Stores high-pass filter values.
	///0: a0; 1: a1; 2: a2; 3: b0; 4: b1; 5: b2; 6: y[n-1] 7: y[n-2]
	protected __m128[8]			hpfVals;
	///Stores high-pass filter control values
	protected float[8]			hpfCtrl	=	[32, 0.707, 32, 0.707, 32, 0.707, 32, 0.707];
	///Initial mixing buffers
	///Output is directed there before filtering
	///Layout is: LRAB
	protected __m128[]			initBuffers;
	///Dummy buffer
	///Only used if one or more outputs haven't been defined
	protected float[]			dummyBuf;
	///Amplitude LFO buffer. Values are between 0.0 and 1.0
	protected float[]			aLFOBuf;
	///Pitch LFO output. Values are between -1.0 and 1.0
	protected float				pLFOOut	=	0;
	///Stores PLFO position
	protected uint				pLFOPos;
	///Stores PLFO rate
	protected uint				pLFORate;
	///Current frequency of PLFO
	protected float				pLFOFreq = 6;
	///Mixdown value.
	///Used for final mixing.
	protected float				mixdownVal = short.max + 1;//4096;
	///Internal sampling frequency
	protected int				intSlmpRate;
	///Internal buffer sizes
	protected size_t			intBufSize;
	alias ChFun = void delegate(int chNum, size_t length) @nogc pure nothrow;
	///Channel update delegates
	protected ChFun[16]			chDeleg;
	///Used as a keepsake for MIDI 1.0 control change values.
	protected ubyte[64]			ccLow;
	/**
	Creates an instance of QM816
	*/
	public this() @trusted nothrow {
		info.nOfAudioInput = 0;
		info.nOfAudioOutput = 4;
		info.outputChNames = ["mainL", "mainR", "auxSendA", "auxSendB"];
		info.isInstrument = true;
		info.hasMidiIn = true;
		info.hasMidiOut = true;
		info.midiSendback = true;
		try {
			WaveFormat f = WaveFormat(0, 0, AudioFormat.PCM, 1, 0, 16);
			short[1024] buffer = generateSinewave([0x01, 0x09, 0x11, 0x19]);
			waveformDataReceive(0, reinterpretCast!ubyte(buffer), f);		///Sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x00]);
			waveformDataReceive(1, reinterpretCast!ubyte(buffer), f);		///Half-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x01, 0x09]);
			waveformDataReceive(2, reinterpretCast!ubyte(buffer), f);		///Full-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x00, 0x01, 0x00]);
			waveformDataReceive(3, reinterpretCast!ubyte(buffer), f);		///Pulse-sine (from OPL2)
			buffer = generateSinewave([0x01, 0x09, 0x11, 0x00]);
			waveformDataReceive(4, reinterpretCast!ubyte(buffer), f);		///Pulse-sine 75%
			buffer = generateSinewave([0x01, 0x00, 0x00, 0x00]);
			waveformDataReceive(5, reinterpretCast!ubyte(buffer), f);		///Pulse-sine 25%
			buffer = generateSinewave([0x01, 0x00, 0x11, 0x00]);
			waveformDataReceive(6, reinterpretCast!ubyte(buffer), f);		///Alternating pulse-sine
			buffer = generateSinewave([0x05, 0x00, 0x1d, 0x00]);
			waveformDataReceive(7, reinterpretCast!ubyte(buffer), f);		///Alternating sine (from OPL3)
			buffer = generateSinewave([0x05, 0x05, 0x1d, 0x1d]);
			waveformDataReceive(8, reinterpretCast!ubyte(buffer), f);		///Camel sine (from OPL3)
			buffer = generateSinewave([0x01, 0x09, 0x11, 0x1f]);
			waveformDataReceive(9, reinterpretCast!ubyte(buffer), f);		///Variant sine 0
			buffer = generateSinewave([0x01, 0x09, 0x1d, 0x1d]);
			waveformDataReceive(10, reinterpretCast!ubyte(buffer), f);		///Variant sine 1
			buffer = generateSinewave([0x01, 0x09, 0x0d, 0x0d]);
			waveformDataReceive(11, reinterpretCast!ubyte(buffer), f);		///Variant sine 2
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x1d]);
			waveformDataReceive(12, reinterpretCast!ubyte(buffer), f);		///Variant sine 3
			buffer = generateSinewave([0x01, 0x09, 0x1d, 0x00]);
			waveformDataReceive(13, reinterpretCast!ubyte(buffer), f);		///Variant sine 4
			buffer = generateSinewave([0x01, 0x09, 0x00, 0x0d]);
			waveformDataReceive(14, reinterpretCast!ubyte(buffer), f);		///Variant sine 5
			buffer = generateSinewave([0x01, 0x09, 0x0d, 0x00]);
			waveformDataReceive(15, reinterpretCast!ubyte(buffer), f);		///Variant sine 6
			buffer = generateSinewave([0x01, 0x09, 0x1f, 0x1f]);
			waveformDataReceive(16, reinterpretCast!ubyte(buffer), f);		///Variant sine 7
			buffer = generatePulseWave(768);
			waveformDataReceive(17, reinterpretCast!ubyte(buffer), f);		///Pulse wave 75%
			buffer = generatePulseWave(512);
			waveformDataReceive(18, reinterpretCast!ubyte(buffer), f);		///Pulse wave 50%
			buffer = generatePulseWave(256);
			waveformDataReceive(19, reinterpretCast!ubyte(buffer), f);		///Pulse wave 25%
			buffer = generatePulseWave(128);
			waveformDataReceive(20, reinterpretCast!ubyte(buffer), f);		///Pulse wave 12.5%
			buffer = generatePulseWave(100);
			waveformDataReceive(21, reinterpretCast!ubyte(buffer), f);		///Pulse wave 10%
			buffer = generatePulseWave(50);
			waveformDataReceive(22, reinterpretCast!ubyte(buffer), f);		///Pulse wave 5%
			buffer = generateTriangularWave(1023);
			waveformDataReceive(23, reinterpretCast!ubyte(buffer), f);		///Ramp wave
			buffer = generateTriangularWave(768);
			waveformDataReceive(24, reinterpretCast!ubyte(buffer), f);		///Morphed ramp
			buffer = generateTriangularWave(512);
			waveformDataReceive(25, reinterpretCast!ubyte(buffer), f);		///Triangle wave
			buffer = generateTriangularWave(256);
			waveformDataReceive(26, reinterpretCast!ubyte(buffer), f);		///Morphed saw
			buffer = generateTriangularWave(2);
			waveformDataReceive(27, reinterpretCast!ubyte(buffer), f);		///Saw wave
		} catch (Exception e) {

		}
		//Reset delegates
		for (int i ; i < chDeleg.length ; i++) {
			chDeleg[i] = &updateChannelM00;
		}
	}
	/**
	 * Sets the module up.
	 *
	 * Can be overridden in child classes to allow resets.
	 */
	public override void moduleSetup(ubyte[] inputs, ubyte[] outputs, int sampleRate, size_t bufferSize, 
			ModuleManager handler) @safe nothrow {
		// void test() @trusted nothrow {
			// midiReceive(UMP(MessageType.MIDI2, 0x0, MIDI2_0Cmd.NoteOn, 0x0, 0x3f, 0x0));
		// }
		enabledInputs = StreamIDSet(inputs);
		enabledOutputs = StreamIDSet(outputs);
		this.sampleRate = sampleRate;
		this.bufferSize = bufferSize;
		this.handler = handler;
		//set up internal sample rate and buffer sizes
		intBufSize = bufferSize + (bufferSize / 4);
		intSlmpRate = sampleRate + (sampleRate / 4);
		//set up and reset buffers
		initBuffers.length = intBufSize;
		resetBuffer(initBuffers);
		dummyBuf.length = bufferSize;
		resetBuffer(dummyBuf);
		aLFOBuf.length = intBufSize;
		resetBuffer(aLFOBuf);
		//Reset filters
		for (int i ; i < 4 ; i++) {
			resetLPF(i);
			resetHPF(i);
		}
		aLFO_y1 = 0;
		setALFO();
		setPLFO();
		//Reset operator EGs
		for (int i ; i < operators.length ; i++) {
			operators[i].setEG(intSlmpRate, 40);
		}
		//Reset channel EGs
		for (int i ; i < channels.length ; i++) {
			channels[i].setEEG(intSlmpRate);
			channels[i].recalculateOutLevels();
		}
		//test();
	}
	protected void resetLPF(int i) @nogc @safe pure nothrow {
		BiquadFilterValues vals = createLPF(sampleRate, filterCtrl[i * 2], filterCtrl[(i * 2) + 1]);
		filterVals[0][i] = vals.a0;
		filterVals[1][i] = vals.a1;
		filterVals[2][i] = vals.a2;
		filterVals[3][i] = vals.b0;
		filterVals[4][i] = vals.b1;
		filterVals[5][i] = vals.b2;
		filterVals[6][i] = 0;
		filterVals[7][i] = 0;
		filterVals[8][i] = 0;
		filterVals[9][i] = 0;
	}
	protected void resetHPF(int i) @nogc @safe pure nothrow {
		BiquadFilterValues hpf = createHPF(sampleRate, hpfCtrl[i * 2], hpfCtrl[(i * 2) + 1]);
		hpfVals[0][i] = hpf.a0;
		hpfVals[1][i] = hpf.a1;
		hpfVals[2][i] = hpf.a2;
		hpfVals[3][i] = hpf.b0;
		hpfVals[4][i] = hpf.b1;
		hpfVals[5][i] = hpf.b2;
		hpfVals[6][i] = 0;
		hpfVals[7][i] = 0;
	}
	/**
	 * Receives waveform data that has been loaded from disk for reading. Returns zero if successful, or a specific 
	 * errorcode.
	 *
	 * id: The ID of the waveform.
	 * rawData: The data itself, in unprocessed form.
	 * format: The format of the wave data, including the data type, bit depth, base sampling rate
	 *
	 * Note: This function needs the audio system to be unlocked.
	 */
	public override int waveformDataReceive(uint id, ubyte[] rawData, WaveFormat format) nothrow {
		int errorcode;
		if (format.channels != 1) errorcode |= SampleLoadErrorCode.ChNumNotSupported;
		if (format.bitsPerSample != 16) errorcode |= SampleLoadErrorCode.BitdepthNotSupported;
		if (format.format != AudioFormat.PCM) errorcode |= SampleLoadErrorCode.FormatNotSupported;
		if (rawData.length != 128 * 1024 * 2 && rawData.length != 1024 * 2) 
			errorcode |= SampleLoadErrorCode.SampleLenghtNotSupported;
		if (errorcode) {
			return errorcode;
		} else {
			import core.stdc.string : memcpy;
			if (rawData.length == 128 * 1024 * 2)
				memcpy(wavetables.ptr, rawData.ptr, 128 * 1024 * 2);
			else
				memcpy(wavetables[id].ptr, rawData.ptr, 1024 * 2);
			return 0;
		}
	}
	/**
	 * MIDI 2.0 data received here.
	 *
	 * data0: Header of the up to 128 bit MIDI 2.0 data.
	 * data1-3: Other packets if needed.
	 */
	public override void midiReceive(UMP data0, uint data1 = 0, uint data2 = 0, uint data3 = 0) @nogc nothrow {
		//data0 = UMP(MessageType.MIDI2, 0x0, MIDI2_0Cmd.NoteOn, 0x0, 0x3f, 0x0);
		switch (data0.msgType) {
			case MessageType.SysCommMsg:	//Process system common message
				break;
			case MessageType.MIDI1:			//Process MIDI 1.0 messages
				switch (data0.status) {
					case MIDI1_0Cmd.CtrlCh:	//Process MIDI 1.0 control change messages
						switch (data0.note) {
							case 0, 32:			//Bank select
								bankNum[data0.channel] = data0.value & 7;
								break;
							case 1, 33:			//Modulation wheel
								ccLow[data0.note] = data0.value;
								chCtrls[data0.channel].modwheel = cast(double)((ccLow[1]<<7) + ccLow[33]) / (ushort.max>>2);
								break;
							case 2, 34:
								ccLow[data0.note] = data0.value;
								chCtrls[data0.channel].auxCtrl = cast(double)((ccLow[2]<<7) + ccLow[34]) / (ushort.max>>2);
								break;
							case 6, 38:			//Data Entry
								ccLow[data0.note] = data0.value;
								paramTemp = [0xFF,0xFF,0xFF,0xFF];
								break;
							case 18, (32+18):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[18], ccLow[32+18]), [0, 0], data0.channel);
								break;
							case 19, (32+19):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[19], ccLow[32+19]), [1, 0], data0.channel);
								break;
							case 16, (32+16):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[16], ccLow[32+16]), [0, 3], data0.channel);
								break;
							case 17, (32+17):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[17], ccLow[32+17]), [1, 3], data0.channel);
								break;
							case 20, (32+20):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[20], ccLow[32+20]), [0, 10], data0.channel);
								break;
							case 22, (32+22):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[22], ccLow[32+22]), [1, 10], data0.channel);
								break;
							case 21, (32+21):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[21], ccLow[32+21]), [0, 10], data0.channel);
								break;
							case 23, (32+23):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[23], ccLow[32+23]), [1, 10], data0.channel);
								break;
							case 30, (32+30):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[30], ccLow[32+30]), [0, 9], data0.channel);
								break;
							case 31, (32+31):
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[31], ccLow[32+31]), [1, 9], data0.channel);
								break;
//
							case 73:
								setUnregisteredParam(data0.value<<25, [1, 1], data0.channel);
								break;
							case 78:
								setUnregisteredParam(data0.value<<25, [0, 1], data0.channel);
								break;
							case 74:
								setUnregisteredParam(data0.value<<25, [1, 2], data0.channel);
								break;
							case 79:
								setUnregisteredParam(data0.value<<25, [0, 2], data0.channel);
								break;
							case 85:
								setUnregisteredParam(data0.value<<25, [0, 4], data0.channel);
								break;
							case 86:
								setUnregisteredParam(data0.value<<25, [1, 4], data0.channel);
								break;
							case 87:
								setUnregisteredParam(data0.value<<25, [0, 8], data0.channel);
								break;
							case 88:
								setUnregisteredParam(data0.value<<25, [1, 8], data0.channel);
								break;
							case 72:
								setUnregisteredParam(data0.value<<25, [1, 5], data0.channel);
								break;
							case 77:
								setUnregisteredParam(data0.value<<25, [0, 5], data0.channel);
								break;
							case 70:
								setUnregisteredParam(data0.value<<25, [1, 6], data0.channel);
								break;
							case 75:
								setUnregisteredParam(data0.value<<25, [0, 6], data0.channel);
								break;
							case 71:
								setUnregisteredParam(data0.value<<25, [1, 7], data0.channel);
								break;
							case 76:
								setUnregisteredParam(data0.value<<25, [0, 7], data0.channel);
								break;
//
							case 7, 32+7:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[7], ccLow[32+7]), [4, 0], data0.channel);
								break;
							case 8, 32+8:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[8], ccLow[32+8]), [4, 1], data0.channel);
								break;
							case 24, 32+24:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[24], ccLow[32+24]), [4, 11], data0.channel);
								break;
							case 25, 32+25:
								ccLow[data0.note] = data0.value;
								setUnregisteredParam(convertM1CtrlValToM2(ccLow[25], ccLow[32+25]), [4, 12], data0.channel);
								break;
//
							case 91:
								setUnregisteredParam(data0.value<<25, [4, 2], data0.channel);
								break;
							case 92:
								setUnregisteredParam(data0.value<<25, [4, 3], data0.channel);
								break;
							case 93:
								setUnregisteredParam(data0.value<<25, [4, 4], data0.channel);
								break;
							case 94:
								setUnregisteredParam(data0.value<<25, [4, 5], data0.channel);
								break;
							case 102:
								setUnregisteredParam(data0.value<<25, [4, 6], data0.channel);
								break;
							case 103:
								setUnregisteredParam(data0.value<<25, [4, 7], data0.channel);
								break;
							case 104:
								setUnregisteredParam(data0.value<<25, [4, 8], data0.channel);
								break;
							case 105:
								setUnregisteredParam(data0.value<<25, [4, 9], data0.channel);
								break;
							case 106:
								setUnregisteredParam(data0.value<<25, [4, 10], data0.channel);
								break;
							case 107:
								setUnregisteredParam(data0.value<<25, [4, 13], data0.channel);
								break;
//
							case 98:		//Non Registered Parameter Number MSB (handle through MIDI 2.0)
								paramTemp[0] = data0.value;
								if (paramTemp[0] != 0xFF)
									setUnregisteredParam(convertM1CtrlValToM2(paramTemp[0], paramTemp[1]), [ccLow[6], ccLow[38]], data0.channel);
								break;
							case 99:		//Non Registered Parameter Number LSB (handle through MIDI 2.0)
								//setUnregisteredParam(data0.value, paramNum, 0, data0.channel);
								paramTemp[1] = data0.value;
								if (paramTemp[0] != 0xFF)
									setUnregisteredParam(convertM1CtrlValToM2(paramTemp[0], paramTemp[1]), [ccLow[6], ccLow[38]], data0.channel);
								break;
							default:
								break;
						}
						break;
					case MIDI1_0Cmd.NoteOn:	//Note on command
						keyOn(data0.note, data0.channel, data0.value/127.0);
						break;
					case MIDI1_0Cmd.NoteOff://Note off command
						keyOff(data0.note, data0.channel, data0.value/127.0);
						break;
					case MIDI1_0Cmd.ChAftrTch:
						chCtrls[data0.channel].velocity = cast(double)data0.note / cast(double)byte.max;
						break;
					case MIDI1_0Cmd.PolyAftrTch:
						chCtrls[data0.channel].velocity = cast(double)data0.velocity / cast(double)byte.max;
						break;
					case MIDI1_0Cmd.PrgCh:	//Program change
						const uint chOffset = data0.channel;
						const uint chCtrl = soundBank[bankNum[chOffset] & 7][presetNum[chOffset]].channel.chCtrl;
						if (chCtrl & ChCtrlFlags.ComboModeTest) {
							const uint chX = chOffset & 7, bankX = bankNum[chOffset] & 7 & ~1;
							prgRecall(chX, presetNum[chX], bankX);
							prgRecall(chX + 8, presetNum[chX], bankX + 1);
						} else {
							prgRecall(chOffset, presetNum[chOffset], bankNum[chOffset]);
						}
						break;
					case MIDI1_0Cmd.PitchBend:
						const uint ch = data0.channel;
						chCtrls[ch].pitchBend = channels[ch].preset.pitchBendSens * ((cast(double)data0.bend - 0x20_00) / 0x3F_FF);
						break;
					default:
						assert(0, "MIDI 1.0 data error!");
						//break;
				}
				break;
			case MessageType.MIDI2:
				switch (data0.status) {
					case MIDI2_0Cmd.CtrlChOld:
						switch (data0.index) {
							case 1:
								chCtrls[data0.channel].modwheel = cast(double)data1 / uint.max;
								break;
							case 2:
								chCtrls[data0.channel].auxCtrl = cast(double)data1 / uint.max;
								break;
							default:
								break;
						}
						break;
					case MIDI2_0Cmd.CtrlCh:	//Control change
						setUnregisteredParam(data1, [data0.index, data0.value], data0.channel);
						break;
					case MIDI2_0Cmd.CtrlChR://Registered control change
						//setRegisteredParam(data[1], [data0.index, data0.value], data0.channel);
						break;
					case MIDI2_0Cmd.PrgCh:	//Program change
						const uint chOffset = data0.channel;
						//const uint prg = data[1]>>24, bank = data[1] & 7;
						presetNum[chOffset] = cast(ubyte)(data1>>24);
						if (data0.value & 1) bankNum[chOffset] = cast(ubyte)(data1 & 7);
						const uint chCtrl = soundBank[bankNum[chOffset] & 7][presetNum[chOffset]].channel.chCtrl;
						if (chCtrl & ChCtrlFlags.ComboModeTest) {
							const uint chX = chOffset & 7, bankX = bankNum[chOffset] & 7 & ~1;
							prgRecall(chX, presetNum[chX], bankX);
							prgRecall(chX + 8, presetNum[chX], bankX + 1);
						} else {
							prgRecall(chOffset, presetNum[chOffset], bankNum[chOffset]);
						}
						break;
					case MIDI2_0Cmd.NoteOn:
						NoteVals v = *cast(NoteVals*)(&data1);
						keyOn(data0.note, data0.channel, v.velocity/65_535.0);
						break;
					case MIDI2_0Cmd.NoteOff:
						NoteVals v = *cast(NoteVals*)(&data1);
						keyOff(data0.note, data0.channel, v.velocity/65_535.0);
						break;
					case MIDI2_0Cmd.PitchBend:
						const uint ch = data0.channel;
						/+const double pitchBendSens = (channels[ch].preset.pitchBendSens>>25) + 
								(cast(double)(channels[ch].preset.pitchBendSens & 0x01_FF_FF_FF) / 0x01_FF_FF_FF);+/
						chCtrls[ch].pitchBend = channels[ch].preset.pitchBendSens * ((cast(double)data1 - int.max) / (int.max));
						break;
					default:
						assert(0, "MIDI 2.0 data error!");
						//break;
				}
				break;
			default:
				//assert(0, "Something went really wrong!");
				break;
		}
	}
	/** 
	 * Implements a key-on event.
	 * Params:
	 *   note = identifies which key is being pressed. Affects KSL control parameters
	 *   ch = channel number
	 *   vel = key velocity
	 *   bend = amount of initial bend (MIDI 2.0 only)
	 */
	protected void keyOn(ubyte note, ubyte ch, float vel, float bend = float.nan) @nogc pure nothrow {
		void hardReset() @safe @nogc pure nothrow {
			channels[ch].eeg.keyOn();
			operators[ch].eg.keyOn();
			operators[ch + 1].eg.keyOn();
			operators[ch].pos = 0;
			operators[ch + 1].pos = 0;
		}
		void softReset() @safe @nogc pure nothrow {
			channels[ch].eeg.keyOnNoReset();
			operators[ch].eg.keyOnNoReset();
			operators[ch + 1].eg.keyOnNoReset();
		}
		void hardResetCmb() @safe @nogc pure nothrow {
			channels[ch + 8].eeg.keyOn();
			operators[ch + 16].eg.keyOn();
			operators[ch + 17].eg.keyOn();
			operators[ch + 16].pos = 0;
			operators[ch + 17].pos = 0;
		}
		void softResetCmb() @safe @nogc pure nothrow {
			channels[ch + 8].eeg.keyOnNoReset();
			operators[ch + 16].eg.keyOnNoReset();
			operators[ch + 17].eg.keyOnNoReset();
		}
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch > 7) return;
		chCtrls[ch].note = note;
		chCtrls[ch].velocity = vel;
		if (!isNaN(bend)) chCtrls[ch].pitchBend = bend;
		operators[ch].setFrequency(intSlmpRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
		operators[ch].setEG(intSlmpRate, note, vel);
		operators[ch + 1].setFrequency(intSlmpRate, note, chCtrls[ch + 1].pitchBend, channels[ch].preset.chnlTun);
		operators[ch + 1].setEG(intSlmpRate, note, vel);
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch <= 7) {
			operators[ch + 16].setFrequency(intSlmpRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
			operators[ch + 16].setEG(intSlmpRate, note, vel);
			operators[ch + 17].setFrequency(intSlmpRate, note, chCtrls[ch].pitchBend, channels[ch].preset.chnlTun);
			operators[ch + 17].setEG(intSlmpRate, note, vel);
			if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetOnKeyOn) {
				hardReset();
				hardResetCmb();
			} else if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetMode) {
				if ((channels[ch].eeg.position | channels[ch + 8].eeg.position | operators[ch].eg.position |
						operators[ch + 1].eg.position | operators[ch + 16].eg.position | operators[ch + 17].eg.position) == 
						ADSREnvelopGenerator.Stage.Off) {
					hardReset();
					hardResetCmb();
				} else {
					softReset();
					softResetCmb();
				}
			} else {
				softReset();
				softResetCmb();
			}
		} else {
			if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetOnKeyOn) {
				hardReset();
			} else if (channels[ch].preset.chCtrl & ChCtrlFlags.ResetMode) {
				if ((channels[ch].eeg.position | operators[ch].eg.position | operators[ch + 1].eg.position) == 
						ADSREnvelopGenerator.Stage.Off) {
					hardReset();
				} else {
					softReset();
				}
			} else {
				softReset();
			}
		}
	}
	/** 
	 * Implements a key-off event.
	 * Params:
	 *   note = 
	 *   ch = 
	 *   vel = 
	 */
	protected void keyOff(ubyte note, ubyte ch, float vel, float bend = 0) @nogc pure nothrow {
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch > 7) return;
		chCtrls[ch].note = note;
		chCtrls[ch].velocity = vel;
		channels[ch].eeg.keyOff();
		operators[ch].keyOff(intSlmpRate);
		operators[ch + 1].keyOff(intSlmpRate);
		if ((channels[ch].preset.chCtrl & ChCtrlFlags.ComboModeTest) && ch <= 7) {
			channels[ch + 8].eeg.keyOff();
			operators[ch + 16].keyOff(intSlmpRate);
			operators[ch + 17].keyOff(intSlmpRate);
		}
	}
	/**
	Sets the channel delegates
	*/
	protected void setChDeleg(uint chCtrl, uint chNum, uint chCtrl0 = 0) @nogc @safe pure nothrow {
		if (chCtrl & ChCtrlFlags.ComboModeTest) {	//Test if channel is combined or not
			if (chNum < 8) {
				const uint algID = (chCtrl & (ChCtrlFlags.ComboModeTest | ChCtrlFlags.Algorithm)) | 
						((chCtrl0 & ChCtrlFlags.Algorithm)<<1);
				enum priChAlg = ChCtrlFlags.Algorithm;
				enum secChAlg = ChCtrlFlags.Algorithm<<1;
				switch (algID) {
					case ChCtrlFlags.ComboMode1:
						chDeleg[chNum] = &updateChannelM100;
						break;
					case ChCtrlFlags.ComboMode1 | secChAlg:
						chDeleg[chNum] = &updateChannelM110;
						break;
					case ChCtrlFlags.ComboMode1 | priChAlg:
						chDeleg[chNum] = &updateChannelM101;
						break;
					case ChCtrlFlags.ComboMode1 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM111;
						break;
					case ChCtrlFlags.ComboMode2:
						chDeleg[chNum] = &updateChannelM200;
						break;
					case ChCtrlFlags.ComboMode2 | secChAlg:
						chDeleg[chNum] = &updateChannelM210;
						break;
					case ChCtrlFlags.ComboMode2 | priChAlg:
						chDeleg[chNum] = &updateChannelM201;
						break;
					case ChCtrlFlags.ComboMode2 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM211;
						break;
					case ChCtrlFlags.ComboMode3:
						chDeleg[chNum] = &updateChannelM300;
						break;
					case ChCtrlFlags.ComboMode3 | secChAlg:
						chDeleg[chNum] = &updateChannelM310;
						break;
					case ChCtrlFlags.ComboMode3 | priChAlg:
						chDeleg[chNum] = &updateChannelM301;
						break;
					case ChCtrlFlags.ComboMode3 | secChAlg | priChAlg:
						chDeleg[chNum] = &updateChannelM311;
						break;
					default:
						chDeleg[chNum] = &updateChannelMD;
						break;
				}
			} else {
				chDeleg[chNum] = &updateChannelMD;
			}
		} else {
			if (chCtrl & ChCtrlFlags.Algorithm) 
				chDeleg[chNum] = &updateChannelM01;
			else
				chDeleg[chNum] = &updateChannelM00;
		}
	}
	/**
	Recalls a program
	*/
	protected void prgRecall(ubyte ch, ubyte prg, ubyte bank) @nogc @safe pure nothrow {
		Preset p = soundBank[bank & 7][prg];
		operators[ch].preset = p.operators[0];
		operators[ch].setEG(intSlmpRate, 40);
		operators[ch + 1].preset = p.operators[1];
		operators[ch + 1].setEG(intSlmpRate, 40);
		channels[ch].preset = p.channel;
		channels[ch].setEEG(intSlmpRate);
	}
	protected void setALFO() @nogc @safe pure nothrow {
		aLFOff = calculateLP6factor(intSlmpRate, aLFOFreq * 512);
		const double cycleLen = aLFOFreq / intSlmpRate / 1024;
		aLFORate = cast(uint)(cycleLen * (1<<22));
	}
	protected void setPLFO() @nogc @safe pure nothrow {
		const double cycleLen = pLFOFreq / intSlmpRate / 1024;
		pLFORate = cast(uint)(cycleLen * (1<<22) * intBufSize);
	}
	/**
	Sets a registered parameter

	If type is not zero, then the MSB is being set, otherwise the LSB will be used
	*/
	protected void setRegisteredParam(T)(T val, ubyte[2] paramNum, ubyte type, ubyte chNum) @nogc @safe pure nothrow {
		switch (paramNum[0]) {
			case ChannelRegParams.PitchBendSens:
				static if (is(T == uint)) {
					channels[chNum].pitchBendSens = (cast(double)val / (uint.max / 127.0));
				} else static if (is(T == ubyte)) {
					const int whole = cast(int)(channels[chNum].pitchBendSens);
					if (type) {
						channels[chNum].pitchBendSens = whole + (val / byte.max);
					} else {
						channels[chNum].pitchBendSens = (channels[chNum].pitchBendSens - whole) * val;
					}
				}
				break;
			case ChannelRegParams.TuneFine:			//Channel master tuning (fine)
				break;
			case ChannelRegParams.TuneCor:			//Channel master tuning (coarse)
				break;
			default: break;
		}
	}
	/**
	Sets an unregistered parameter (MIDI 2.0)

	If type is not zero, then the MSB is being set, otherwise the LSB will be used
	*/
	protected void setUnregisteredParam(uint val, ubyte[2] paramNum, ubyte chNum) @nogc @safe pure nothrow {
		void setOpParam(int opNum) {
			switch (paramNum[0]) {
				case OperatorParamNums.Attack:
					operators[opNum].preset.atk = cast(ubyte)(val >> 25);
					operators[opNum].setEG(intSlmpRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.Decay:
					operators[opNum].preset.dec = cast(ubyte)(val >> 25);
					operators[opNum].setEG(intSlmpRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.Feedback:
					const double valF = cast(double)val / uint.max;
					operators[opNum].preset.fbL = pow(valF, 2.5) * (operators[opNum].preset.opCtrl & OpCtrlFlags.FBNeg ? -1 : 1);
					break;
				case OperatorParamNums.Level:
					const double valF = cast(double)val / uint.max;
					operators[opNum].preset.outL = valF * valF;
					operators[opNum].calculateKSL(chCtrls[chNum].note);
					break;
				case OperatorParamNums.OpCtrl:
					operators[opNum].preset.opCtrl &= OpCtrlFlags.WavetableSelect;
					operators[opNum].preset.opCtrl |= val<<7;
					break;
				case OperatorParamNums.Release:
					operators[opNum].preset.rel = cast(ubyte)(val >> 25);
					operators[opNum].setEG(intSlmpRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.ShpA:
					operators[opNum].preset.shpA = cast(double)val / uint.max;
					operators[opNum].setShpVals(chCtrls[chNum].velocity);
					break;
				case OperatorParamNums.ShpR:
					operators[opNum].preset.shpR = cast(double)val / uint.max;
					operators[opNum].setShpVals(chCtrls[chNum].velocity);
					break;
				case OperatorParamNums.SusCtrl:
					operators[opNum].preset.susCC = cast(ubyte)(val >> 25);
					operators[opNum].setEG(intSlmpRate, chCtrls[chNum].note);
					break;
				case OperatorParamNums.SusLevel:
					operators[opNum].eg.sustainLevel = cast(double)val / uint.max;
					//Recalculate decay and release rates to new sustain levels
					if (operators[opNum].preset.dec) {
						operators[opNum].eg.decayRate = calculateRate(ADSR_TIME_TABLE[operators[opNum].preset.dec] * 2, intSlmpRate, 
								ADSREnvelopGenerator.maxOutput, operators[opNum].eg.sustainLevel);
					} else {
						operators[opNum].eg.decayRate = 1.0;
					}
					if (operators[opNum].preset.rel) {
						operators[opNum].eg.releaseRate = calculateRate(ADSR_TIME_TABLE[operators[opNum].preset.rel] * 2, intSlmpRate, 
								operators[opNum].eg.sustainLevel);
					} else {
						operators[opNum].eg.releaseRate = 1.0;
					}
					break;
				case OperatorParamNums.TuneCor:
					if (operators[opNum].preset.opCtrl & OpCtrlFlags.ContiTune) {
						operators[opNum].preset.tune = cast(double)val / 0x02_00_00_00;
					} else {
						operators[opNum].preset.opCtrl &= ~TuneCtrlFlags.CorTuneTest; 
						operators[opNum].preset.opCtrl |= val & TuneCtrlFlags.CorTuneTest;
					}
					
					break;
				case OperatorParamNums.TuneFine:
					if (!(operators[opNum].preset.opCtrl & OpCtrlFlags.ContiTune))
						operators[opNum].preset.tune = (cast(double)val - int.min) / int.max;
					break;
				case OperatorParamNums.VelToLevel:
					operators[opNum].preset.outLCtrl[0] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.MWToLevel:
					operators[opNum].preset.outLCtrl[1] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.LFOToLevel:
					operators[opNum].preset.outLCtrl[2] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToFB:
					operators[opNum].preset.fbLCtrl[0] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.MWToFB:
					operators[opNum].preset.fbLCtrl[1] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.LFOToFB:
					operators[opNum].preset.fbLCtrl[2] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.EEGToFB:
					operators[opNum].preset.fbLCtrl[3] = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToShpA:
					operators[opNum].preset.shpAVel = cast(double)val / uint.max;
					break;
				case OperatorParamNums.VelToShpR:
					operators[opNum].preset.shpRVel = cast(double)val / uint.max;
					break;
				case OperatorParamNums.Waveform:
					operators[opNum].preset.opCtrl &= ~OpCtrlFlags.WavetableSelect;
					operators[opNum].preset.opCtrl |= cast(ubyte)(val >> 25);
					break;
				case OperatorParamNums.KSLBegin:
					const ubyte newval = cast(ubyte)(val>>25);
					if (newval == 127)
						operators[opNum].preset.kslBegin = ubyte.max;
					else
						operators[opNum].preset.kslBegin = newval;
					break;
				case OperatorParamNums.KSLAttenOut:
					operators[opNum].preset.kslAttenOut = cast(ubyte)(val>>24);
					break;
				case OperatorParamNums.KSLAttenFB:
					operators[opNum].preset.kslAttenFB = cast(ubyte)(val>>24);
					break;
				case OperatorParamNums.KSLAttenADSR:
					operators[opNum].preset.kslAttenADSR = cast(ubyte)(val>>24);
					break;
				default: break;
			}
		}
		void setOpFlag(int opNum){
			if (val) 
				operators[opNum].preset.opCtrl |= 1<<(paramNum[0] + 7);
			else
				operators[opNum].preset.opCtrl &= ~(1<<(paramNum[0] + 7));
		}
		switch (paramNum[1]) {
			case 0:			//Channel operator 0
				//chNum *= 2;
				setOpParam(chNum * 2);
				break;
			case 1:			//Channel operator 1
				//chNum *= 2;
				setOpParam((chNum * 2) + 1);
				break;
			case 2:			//Channel operator 0 flags
				setOpFlag(chNum * 2);
				break;
			case 3:			//Channel operator 1 flags
				setOpFlag((chNum * 2) + 1);
				break;
			case 4:			//Channel common values
				switch (paramNum[0]) { 
					//case ChannelParamNums.ALFO: break;
					case ChannelParamNums.Attack:
						channels[chNum].preset.atkX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.atkX) {
							channels[chNum].eeg.attackRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.atkX], intSlmpRate);
						} else {
							channels[chNum].eeg.attackRate = 1.0;
						}
						break;
					case ChannelParamNums.AuxSLA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						channels[chNum].preset.auxSendA = channels[chNum].outLevels[2];
						break;
					case ChannelParamNums.AuxSLB: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						channels[chNum].preset.auxSendB = channels[chNum].outLevels[3];
						break;
					case ChannelParamNums.Bal: 
						channels[chNum].preset.masterBal = cast(double)val / uint.max;
						if (channels[chNum].preset.chCtrl & ChCtrlFlags.IndivOutChLev) {
							channels[chNum].outLevels[1] = channels[chNum].preset.masterBal * channels[chNum].preset.masterBal;
						} else {
							channels[chNum].outLevels[0] = channels[chNum].preset.masterVol - channels[chNum].preset.masterBal;
							channels[chNum].outLevels[1] = channels[chNum].preset.masterVol - (1.0 - channels[chNum].preset.masterBal);
						}
						break;
					case ChannelParamNums.ChCtrl:
						channels[chNum].preset.chCtrl = val;
						//mirror operator configuration parameters between paired channels
						if (chNum < 8) {
							channels[chNum + 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
							channels[chNum + 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
						} else {
							channels[chNum - 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
							channels[chNum - 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
						}
						break;
					//case ChannelParamNums.ChCtrlL: break;
					case ChannelParamNums.Decay:
						channels[chNum].preset.decX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.decX) {
							channels[chNum].eeg.decayRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.decX] * 2, intSlmpRate);
						} else {
							channels[chNum].eeg.decayRate = 1.0;
						}
						break;
					case ChannelParamNums.EEGDetune:
						channels[chNum].preset.eegDetuneAm = ((cast(double)(uint.max>>1) - cast(double)val) / (uint.max>>1)) * 24;
						break;
					case ChannelParamNums.MasterVol: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].outLevels[2] = valF * valF;
						if (channels[chNum].preset.chCtrl & ChCtrlFlags.IndivOutChLev) {
							channels[chNum].outLevels[1] = channels[chNum].preset.masterBal * channels[chNum].preset.masterBal;
						} else {
							channels[chNum].outLevels[0] = channels[chNum].preset.masterVol - channels[chNum].preset.masterBal;
							channels[chNum].outLevels[1] = channels[chNum].preset.masterVol - (1.0 - channels[chNum].preset.masterBal);
						}
						break;
					case ChannelParamNums.PLFO: 
						channels[chNum].preset.pLFOlevel = cast(double)val / uint.max;
						break;
					case ChannelParamNums.Release: 
						channels[chNum].preset.relX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.relX) {
							channels[chNum].eeg.releaseRate = calculateRate(ADSR_TIME_TABLE[channels[chNum].preset.relX] * 2, intSlmpRate);
						} else {
							channels[chNum].eeg.releaseRate = 1.0;
						}
						break;
					case ChannelParamNums.ShpA:
						channels[chNum].preset.shpAX = cast(double)val / uint.max;
						break;
					case ChannelParamNums.ShpR:
						channels[chNum].preset.shpRX = cast(double)val / uint.max;
						break;
					case ChannelParamNums.SusCtrl: 
						channels[chNum].preset.susCCX = cast(ubyte)(val >> 25);
						if (channels[chNum].preset.susCCX) {
							channels[chNum].eeg.isPercussive = false;
							if (channels[chNum].preset.susCCX == 64) {
								channels[chNum].eeg.sustainControl = 0.0;
							} else if (channels[chNum].preset.susCCX < 64) {
								channels[chNum].eeg.sustainControl = -1.0 * 
										calculateRate(SUSTAIN_CONTROL_TIME_TABLE[channels[chNum].preset.susCCX - 1], intSlmpRate);
							} else {
								channels[chNum].eeg.sustainControl = 
										calculateRate(SUSTAIN_CONTROL_TIME_TABLE[channels[chNum].preset.susCCX - 64], intSlmpRate);
							}
						} else {
							channels[chNum].eeg.isPercussive = true;
							channels[chNum].eeg.sustainControl = 0.0;
						}
						break;
					case ChannelParamNums.SusLevel: 
						channels[chNum].eeg.sustainLevel = cast(double)val / uint.max;
						channels[chNum].preset.susLevel = channels[chNum].eeg.sustainLevel;
						break;
					case ChannelParamNums.GlobalFB: 
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.globalFb = valF * valF;
						break;
					case ChannelParamNums.EEGToLeft:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[0] = valF * valF;
						break;
					case ChannelParamNums.EEGToRight:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[1] = valF * valF;
						break;
					case ChannelParamNums.EEGToAuxA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[2] = valF * valF;
						break;
					case ChannelParamNums.EEGToAuxB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.eegLevels[3] = valF * valF;
						break;
					case ChannelParamNums.LFOToLeft:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[0] = valF * valF;
						break;
					case ChannelParamNums.LFOToRight:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[1] = valF * valF;
						break;
					case ChannelParamNums.LFOToAuxA:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[2] = valF * valF;
						break;
					case ChannelParamNums.LFOToAuxB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.aLFOlevels[3] = valF * valF;
						break;
					case ChannelParamNums.MWToGFB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.mwToGFB = valF;
						break;
					case ChannelParamNums.VelToGFB:
						const double valF = cast(double)val / uint.max;
						channels[chNum].preset.velToGFB = valF;
						break;
					default:
						break;
				}
				break;
			case 5:		//Channel common flags
				if (val)
					channels[chNum].preset.chCtrl |= 1<<paramNum[0];
				else
					channels[chNum].preset.chCtrl &= ~(1<<paramNum[0]);
				if (chNum < 8) {
					channels[chNum + 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
					channels[chNum + 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
					setChDeleg(channels[chNum].preset.chCtrl, chNum, channels[chNum + 8].preset.chCtrl);
					setChDeleg(channels[chNum + 8].preset.chCtrl, chNum + 8);
				} else {
					channels[chNum - 8].preset.chCtrl &= ~ChCtrlFlags.ComboModeTest;
					channels[chNum - 8].preset.chCtrl |= ChCtrlFlags.ComboModeTest & channels[chNum].preset.chCtrl;
					setChDeleg(channels[chNum - 8].preset.chCtrl, chNum - 8, channels[chNum].preset.chCtrl);
					setChDeleg(channels[chNum].preset.chCtrl, chNum);
				}
				break;
			case 16:		//LFO and master filter settings
				void setFilterFreq(int num) @nogc @safe pure nothrow {
					const double valF = cast(double)val / uint.max;
					filterCtrl[num] = valF * valF * 20_000;
				}

				void setFilterQ(int num) @nogc @safe pure nothrow {
					const double valF = cast(double)val / uint.max;
					filterCtrl[num] = valF * 2;
				}

				switch (paramNum[0]) {
					case GlobalParamNums.PLFORate:
						double valF;
						valF = cast(double)val / uint.max;
						valF *= 16;
						setPLFO();
						break;
					case GlobalParamNums.PLFOWF:
						lfoWaveform[0] = cast(ubyte)(val >> 25);
						break;
					case GlobalParamNums.ALFORate:
						if (lfoWaveform[1 & 0x80]) {
							aLFOFreq = noteToFreq((cast(double)val) / 0x02_00_00_00, 440);
						} else {
							aLFOFreq = cast(double)val / uint.max;
							aLFOFreq *= 16;
						}
						setALFO();
						break;
					case GlobalParamNums.ALFOWF:
						lfoWaveform[1] = cast(ubyte)(val >> 25);
						break;
					case GlobalParamNums.FilterLCFreq:
						const double valF = cast(double)val / uint.max;
						filterCtrl[0] = valF * valF * 20_000;
						resetLPF(0);
						break;
					case GlobalParamNums.FilterLCQ: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[1] = valF * 2;
						resetLPF(0);
						break;
					case GlobalParamNums.FilterRCFreq: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[2] = valF * valF * 20_000;
						resetLPF(1);
						break;
					case GlobalParamNums.FilterRCQ: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[3] = valF * 2;
						resetLPF(1);
						break;
					case GlobalParamNums.FilterACFreq:
						const double valF = cast(double)val / uint.max;
						filterCtrl[4] = valF * valF * 20_000;
						resetLPF(2);
						break;
					case GlobalParamNums.FilterACQ: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[5] = valF * 2;
						resetLPF(2);
						break;
					case GlobalParamNums.FilterBCFreq: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[6] = valF * valF * 20_000;
						resetLPF(3);
						break;
					case GlobalParamNums.FilterBCQ: 
						const double valF = cast(double)val / uint.max;
						filterCtrl[7] = valF * 2;
						resetLPF(3);
						break;
					case GlobalParamNums.HPFLCFreq:
						const double valF = cast(double)val / uint.max;
						hpfCtrl[0] = valF * valF * 20_000;
						resetHPF(0);
						break;
					case GlobalParamNums.HPFLCQ: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[1] = valF * 2;
						resetHPF(0);
						break;
					case GlobalParamNums.HPFRCFreq: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[2] = valF * valF * 20_000;
						resetHPF(1);
						break;
					case GlobalParamNums.HPFRCQ: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[3] = valF * 2;
						resetHPF(1);
						break;
					case GlobalParamNums.HPFACFreq:
						const double valF = cast(double)val / uint.max;
						hpfCtrl[4] = valF * valF * 20_000;
						resetHPF(2);
						break;
					case GlobalParamNums.HPFACQ: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[5] = valF * 2;
						resetHPF(2);
						break;
					case GlobalParamNums.HPFBCFreq: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[6] = valF * valF * 20_000;
						resetHPF(3);
						break;
					case GlobalParamNums.HPFBCQ: 
						const double valF = cast(double)val / uint.max;
						hpfCtrl[7] = valF * 2;
						resetHPF(3);
						break;
					case GlobalParamNums.RingMod:
						if (val)
							lfoWaveform[1] |= 0b1000_0000;
						else
							lfoWaveform[1] &= 0b0111_1111;
						break;
					default:
						break;
				}
				break;
			default: break;
		}
	}
	/**
	 * Renders the current audio frame.
	 * 
	 * input: the input buffers if any, null if none.
	 * output: the output buffers if any, null if none.
	 *
	 * NOTE: Buffers must have matching sizes.
	 */
	public override void renderFrame(float*[] input, float*[] output) @nogc nothrow {
		//Generate aLFO table with filtering
		for (int i ; i < intBufSize ; i++) {
			const float x = (wavetables[lfoWaveform[1] & byte.max][aLFOPos>>22] - short.min) * 
					(1 / cast(float)(ushort.max));
			const float y = aLFO_y1 + (x - aLFO_y1) * aLFOff;
			aLFOBuf[i] = y;
			aLFOPos += aLFORate;
			aLFO_y1 = y;
		}
		//Generate pLFO out
		{
			pLFOOut = (wavetables[lfoWaveform[0]][pLFOPos>>22]) * (1 / cast(float)(short.max));
			pLFOPos += pLFORate;
		}
		//Render each channel
		foreach (size_t i, ChFun fun ; chDeleg) {
			
			fun(cast(int)i, intBufSize);
		}
		//chDeleg[0](0, bufferSize);
		//Filter and mix outputs
		float*[4] outBuf;
		for (ubyte i, j ; i < 4 ; i++) {
			if (enabledOutputs.has(i)) {
				outBuf[i] = output[j];
				j++;
			} else {
				outBuf[i] = dummyBuf.ptr;
			}
		}
		const __m128 b0_a0l = filterVals[3] / filterVals[0], b1_a0l = filterVals[4] / filterVals[0], 
				b2_a0l = filterVals[5] / filterVals[0], a1_a0l = filterVals[1] / filterVals[0], 
				a2_a0l = filterVals[2] / filterVals[0],
				b0_a0h = hpfVals[3] / hpfVals[0], b1_a0h = hpfVals[4] / hpfVals[0], b2_a0h = hpfVals[5] / hpfVals[0],
				a1_a0h = hpfVals[1] / hpfVals[0], a2_a0h = hpfVals[2] / hpfVals[0];
		for (int i ; i < bufferSize ; i++) {
			const int intBufPos = (i>>2) * 5;
			const int intBP0 = intBufPos + (i & 3);
			__m128 input0 = (initBuffers[intBP0] * RESAMPLING_TABLE[i & 3][0]) + 
					(initBuffers[intBP0 + 1] * RESAMPLING_TABLE[i & 3][1]);
			input0 /= __m128(mixdownVal);
			input0 = _mm_max_ps(input0, __m128(-1.0));
			input0 = _mm_min_ps(input0, __m128(1.0));
			__m128 output0 = b0_a0l * input0 + b1_a0l * filterVals[6] + b2_a0l * filterVals[7] - a1_a0l * filterVals[8] - 
					a2_a0l * filterVals[9];
			__m128 output1 = b0_a0h * output0 + b1_a0h * filterVals[8] + b2_a0h * filterVals[9] - a1_a0h * hpfVals[6] -
					a2_a0h * hpfVals[7];
			for (int j ; j < 4 ; j++)
				outBuf[j][i] += output1[j];
			//	outBuf[j][i] += input0[j];
			filterVals[7] = filterVals[6];
			filterVals[6] = input0;
			filterVals[9] = filterVals[8];
			filterVals[8] = output0;
			hpfVals[7] = hpfVals[6];
			hpfVals[6] = output1;
			
		}
		resetBuffer(initBuffers);
	}
	///Updates an operator for a cycle
	///chCtrl index notation: 0: velocity, 1: modulation wheel, 2: Amplitude LFO, 3: Extra Envelop Generator
	pragma(inline, true)
	protected final void updateOperator(ref Operator op, __m128 chCtrl) @nogc @safe pure nothrow {
		/+op.output = wavetables
				[op.preset.opCtrl & OpCtrlFlags.WavetableSelect][((op.pos>>21) + (op.input>>2) + (op.feedback>>3)) & 1023];+/
		/+op.output = wavetables
				[op.preset.opCtrl & OpCtrlFlags.WavetableSelect][(op.pos + (op.input<<19) + (op.feedback<<17))>>21 & 1023];+/
		op.output = wavetables
				[op.preset.opCtrl & OpCtrlFlags.WavetableSelect][(op.pos + (op.input<<20) + (op.feedback<<18))>>22 & 1023];
		const double egOut = op.eg.shp(op.eg.position == ADSREnvelopGenerator.Stage.Attack ? op.shpA0 : op.shpR0);
		const double out0 = op.output;
		__m128 outCtrl = (__m128(1.0) - op.preset.outLCtrl) + (op.preset.outLCtrl * chCtrl);
		__m128 fbCtrl = (__m128(1.0) - op.preset.fbLCtrl) + (op.preset.fbLCtrl * chCtrl);
		const double out1 = out0 * egOut;
		
		op.feedback = cast(int)((op.preset.opCtrl & OpCtrlFlags.FBMode ? out0 : out1) * op.fbL * fbCtrl[0] * 
				fbCtrl[1] * fbCtrl[2] * fbCtrl[3]);
		
		op.output_0 = cast(int)(out1 * op.outL * outCtrl[0] * outCtrl[1] * outCtrl[2]);
		op.pos += op.step;
		//op.input = 0;
		op.eg.advance();
	}
	///Updates automatic and manual pitchbend values (channel-assignable envelop, LFO, pitchbend CTRL) for 2 operators.
	pragma(inline, true)
	protected final void updatePitchbend2Op(ref Operator op0, ref Operator op1, ref Channel ch, ref ChControllers chCtrl) 
			@nogc @safe pure nothrow {
		if (!isClose(ch.preset.eegDetuneAm, 0.0, 0.1) || !isClose(ch.preset.pLFOlevel, 0.0, 0.01)
				|| !isClose(chCtrl.pitchBend, 0.0, 0.01)) {
			const float eegOut = ch.eeg.shp(ch.eeg.position == ADSREnvelopGenerator.Stage.Attack ? 
					ch.preset.shpAX : ch.preset.shpRX);
			const float vibrAm = pLFOOut * ch.preset.pLFOlevel * 
					(ch.preset.chCtrl & ChCtrlFlags.MWToVibr ? chCtrl.pitchBend : 1.0);
			op0.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op1.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
		}
	}
	///Updates automatic and manual pitchbend values (channel-assignable envelop, LFO, pitchbend CTRL) for 4 operators.
	pragma(inline, true)
	protected final void updatePitchbend4Op(ref Operator op0, ref Operator op1, ref Operator op2, ref Operator op3, 
			ref Channel ch, ref ChControllers chCtrl) @nogc @safe pure nothrow {
		if (!isClose(ch.preset.eegDetuneAm, 0.0, 0.1) || !isClose(ch.preset.pLFOlevel, 0.0, 0.01)
				|| !isClose(chCtrl.pitchBend, 0.0, 0.01)) {
			const float eegOut = ch.eeg.shp(ch.eeg.position == ADSREnvelopGenerator.Stage.Attack ? 
					ch.preset.shpAX : ch.preset.shpRX);
			const float vibrAm = pLFOOut * ch.preset.pLFOlevel * 
					(ch.preset.chCtrl & ChCtrlFlags.MWToVibr ? chCtrl.pitchBend : 1.0);
			op0.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op1.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op2.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
			op3.setFrequency(intSlmpRate, chCtrl.note, chCtrl.pitchBend + (ch.preset.eegDetuneAm * eegOut) * vibrAm, ch.preset.chnlTun);
		}
	}
	///Macro for channel update constants that need to be calculated once per frame
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS =
		q{
			const int opOffset = chNum * 2;
			__m128 aLFOOutMW = __m128(channels[chNum].preset.chCtrl & ChCtrlFlags.MWToTrem ? 
					chCtrls[chNum].modwheel : 1.0);
			const float auxSendAmMW = (channels[chNum].preset.chCtrl & ChCtrlFlags.MWToAux ? 
					chCtrls[chNum].modwheel : 1.0);
			__m128 opCtrl0, opCtrl1, mwAuxCtrl;
			opCtrl0[0] = operators[opOffset].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl1[0] = operators[opOffset + 1].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl0[1] = operators[opOffset].preset.opCtrl & OpCtrlFlags.ExprToMW ? chCtrls[chNum].auxCtrl : 
					chCtrls[chNum].modwheel;
			opCtrl1[1] = operators[opOffset + 1].preset.opCtrl & OpCtrlFlags.ExprToMW ? chCtrls[chNum].auxCtrl : 
					chCtrls[chNum].modwheel;
			opCtrl0[1] = operators[opOffset].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - opCtrl0[1] : opCtrl0[1];
			opCtrl1[1] = operators[opOffset + 1].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - opCtrl0[1] : opCtrl0[1];
			mwAuxCtrl[0] = 1.0;
			mwAuxCtrl[1] = 1.0;
			mwAuxCtrl[2] = auxSendAmMW;
			mwAuxCtrl[3] = auxSendAmMW;
			const float lfopan = (channels[chNum].preset.chCtrl & ChCtrlFlags.LFOPan ? 1.0 : 0);
			const float eegpan = (channels[chNum].preset.chCtrl & ChCtrlFlags.EEGPan ? 1.0 : 0);
		};
	///Macro for channel update constants that need to be calculated once per frame, for combined channels' second half
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS0 =
		q{
			__m128 opCtrl2, opCtrl3;
			opCtrl2[0] = operators[opOffset + 16].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl3[0] = operators[opOffset + 17].preset.opCtrl & OpCtrlFlags.VelNeg ? 1 - chCtrls[chNum].velocity : 
					chCtrls[chNum].velocity;
			opCtrl2[1] = operators[opOffset + 16].preset.opCtrl & OpCtrlFlags.ExprToMW ? chCtrls[chNum].auxCtrl : 
					chCtrls[chNum].modwheel;
			opCtrl3[1] = operators[opOffset + 17].preset.opCtrl & OpCtrlFlags.ExprToMW ? chCtrls[chNum].auxCtrl : 
					chCtrls[chNum].modwheel;
			opCtrl2[1] = operators[opOffset + 16].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - opCtrl0[1] : opCtrl0[1];
			opCtrl3[1] = operators[opOffset + 17].preset.opCtrl & OpCtrlFlags.MWNeg ? 1 - opCtrl0[1] : opCtrl0[1];
			const float eegpan0 = (channels[chNum + 8].preset.chCtrl & ChCtrlFlags.EEGPan ? 1.0 : 0);
		};
	///Macro for channel update constants that need to be calculated for each cycle
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS_CYCL = 
		q{
			const float eegOut = channels[chNum].eeg.shp(channels[chNum].eeg.position == 
					ADSREnvelopGenerator.Stage.Attack ? channels[chNum].preset.shpAX : channels[chNum].preset.shpRX);
			__m128 eegToMast = __m128(eegOut), lfoToMast = __m128(aLFOBuf[i]);
			eegToMast[0] = abs(eegpan - eegToMast[0]);
			lfoToMast[0] = abs(lfopan - lfoToMast[0]);
			opCtrl0[2] = aLFOBuf[i];
			opCtrl1[2] = aLFOBuf[i];
			opCtrl0[3] = eegOut;
			opCtrl1[3] = eegOut;
		};
	
	///Macro for channel update constants that need to be calculated for each cycle for combined channels' second half
	///Kept in at one place to make updates easier and more consistent
	static immutable string CHNL_UPDATE_CONSTS_CYCL0 = 
		q{
			const float eegOut0 = channels[chNum + 8].eeg.shp(channels[chNum + 8].eeg.position == 
					ADSREnvelopGenerator.Stage.Attack ? channels[chNum + 8].preset.shpAX : 
					channels[chNum + 8].preset.shpRX);
			__m128 eegToMast0 = __m128(eegOut0);
			eegToMast0[0] = abs(eegpan0 - eegToMast0[0]);
			opCtrl2[2] = aLFOBuf[i];
			opCtrl3[2] = aLFOBuf[i];
			opCtrl2[3] = eegOut0;
			opCtrl3[3] = eegOut0;
		};
			
	///Macro for output mixing
	static immutable string CHNL_UPDATE_MIX =
		q{
			__m128 outlevels = channels[chNum].outLevels * mwAuxCtrl;
			outlevels *= (channels[chNum].preset.eegLevels * eegToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].preset.eegLevels));
			outlevels *= (channels[chNum].preset.aLFOlevels * lfoToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].preset.aLFOlevels));
			initBuffers[i] += outlevels * _mm_cvtepi32_ps(outSum);
		};
	///Macro for output mixing in case of combo modes
	static immutable string CHNL_UPDATE_MIX0 =
		q{
			__m128 outlevels = channels[chNum].outLevels * mwAuxCtrl;
			outlevels *= (channels[chNum].eegLevels * eegToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].eegLevels));
			outlevels *= (channels[chNum + 8].eegLevels * eegToMast0) + (__m128(1.0) - 
			 (__m128(1.0) * channels[chNum + 8].eegLevels));
			outlevels *= (channels[chNum].aLFOlevels * lfoToMast) + (__m128(1.0) - (__m128(1.0) * 
					channels[chNum].aLFOlevels);
			initBuffers[i] += outlevels * _mm_cvtepi32_ps(outSum);
		};
	

	///Algorithm Mode 0/0 (Serial)
	protected void updateChannelM00(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		updatePitchbend2Op(operators[opOffset], operators[opOffset + 1], channels[chNum], chCtrls[chNum]);
		for (size_t i ; i < length ; i++) {
			channels[chNum].eeg.advance();
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			updateOperator(operators[opOffset], opCtrl0);
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);
			operators[opOffset].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
		}
	}
	///Algorithm Mode0/1 (Parallel)
	protected void updateChannelM01(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		updatePitchbend2Op(operators[opOffset], operators[opOffset + 1], channels[chNum], chCtrls[chNum]);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			updateOperator(operators[opOffset], opCtrl0);
			updateOperator(operators[opOffset + 1], opCtrl1);
			//const int outSum = operators[opOffset].output_0 + operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
		}
	}
	///Algorithm Mode1/00 ([S0]->[S1]->[P0]->[P1])
	protected void updateChannelM100(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);

		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	///Dummy algorithm for combined channels
	protected void updateChannelMD(int chNum, size_t length) @nogc pure nothrow {

	}
	/**
	Algorithm Mode1/10
	[S0]\
    	 ->[P0]->[P1]->
	[S1]/
	*/
	protected void updateChannelM110(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode1/01
	[S0]->[S1]->[P0]->
            	[P1]->
	*/
	protected void updateChannelM101(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode1/11
	[S0]\
    	 ->[P0]->
	[S1]/  [P1]->
	*/
	protected void updateChannelM111(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/00
	[S0]->[S1]\
	           ->[P1]->
    	  [P0]/
	*/
	protected void updateChannelM200(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0 + operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/10
	[S0]\
	[S1]-->[P1]->
	[P0]/
	*/
	protected void updateChannelM210(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0 + operators[opOffset + 17].output_0 + 
					operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset + 1].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/01
	          /[P0]->
	[S0]->[S1]
    	      \[P1]->
	*/
	protected void updateChannelM201(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode2/11
	[S0]\ /[P0]->
	     -
	[S1]/ \[P1]->
	*/
	protected void updateChannelM211(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/00
	[S0]->[S1]->
	[P0]->[P1]->
	*/
	protected void updateChannelM300(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 17].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset + 17].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/10
	      [S0]->
    	  [S1]->
	[P0]->[P1]->
	*/
	protected void updateChannelM310(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset].feedback += 
				cast(int)(operators[opOffset + 1].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset + 1].output_0 + operators[opOffset + 17].output_0 + 
					operators[opOffset + 16].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/01
	    />[S1]->
	[S0]->[P0]->
    	\>[P1]->
	*/
	protected void updateChannelM301(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			operators[opOffset].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			operators[opOffset + 1].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			operators[opOffset + 16].feedback += 
				cast(int)(operators[opOffset + 17].output_0 * channels[chNum].preset.globalFb * 
				(channels[chNum].preset.chCtrl & ChCtrlFlags.FBMode ? eegOut : 1));
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset + 1].output_0 + 
					operators[opOffset + 17].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}
	/**
	Algorithm Mode3/11
	[S0]->
	[S1]->
	[P0]->
	[P1]->
	*/
	protected void updateChannelM311(int chNum, size_t length) @nogc pure nothrow {
		mixin(CHNL_UPDATE_CONSTS);
		mixin(CHNL_UPDATE_CONSTS0);
		for (size_t i ; i < length ; i++) {
			mixin(CHNL_UPDATE_CONSTS_CYCL);
			mixin(CHNL_UPDATE_CONSTS_CYCL0);
			updateOperator(operators[opOffset + 16], opCtrl2);	//S0
			//operators[opOffset + 17].input = operators[opOffset + 16].output_0;
			updateOperator(operators[opOffset + 17], opCtrl3);	//S1
			//operators[opOffset].input = operators[opOffset + 17].output_0;
			updateOperator(operators[opOffset], opCtrl0);		//P0
			//operators[opOffset + 1].input = operators[opOffset].output_0;
			updateOperator(operators[opOffset + 1], opCtrl1);	//P1
			//const int outSum = operators[opOffset + 1].output_0;
			__m128i outSum = __m128i(operators[opOffset].output_0 + operators[opOffset].output_0 +
					operators[opOffset + 17].output_0 + operators[opOffset + 16].output_0);
			mixin(CHNL_UPDATE_MIX);
			channels[chNum].eeg.advance();
			channels[chNum + 8].eeg.advance();
		}
	}

	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int writeParam_int(uint presetID, uint paramID, int value) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//op0 begin
			case hashCalc(`op0_Attack`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].atk = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_Decay`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].dec = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_SusCtrl`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].susCC = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_Release`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].rel = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_Waveform`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.WavetableSelect;
					soundBank[bankNum][presetNum].operators[0].opCtrl |= cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_TuneCor`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~TuneCtrlFlags.CorTuneTest;
					soundBank[bankNum][presetNum].operators[0].opCtrl |= (cast(ubyte)value)<<25;
					return 0;
				}
				break;
			case hashCalc(`op0_KSLBegin`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[0].kslBegin = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_KSLAttenOut`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[0].kslAttenOut = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_KSLAttenFB`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslAttenFB = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op0_KSLAttenADSR`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslAttenADSR = cast(ubyte)value;
					return 0;
				}
				break;
			//op0 end

			//op1 begin
			case hashCalc(`op1_Attack`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].atk = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_Decay`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].dec = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_SusCtrl`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].susCC = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_Release`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].rel = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_Waveform`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.WavetableSelect;
					soundBank[bankNum][presetNum].operators[1].opCtrl |= cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_TuneCor`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~TuneCtrlFlags.CorTuneTest;
					soundBank[bankNum][presetNum].operators[1].opCtrl |= (cast(ubyte)value)<<25;
					return 0;
				}
				break;
			case hashCalc(`op1_KSLBegin`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslBegin = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_KSLAttenOut`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslAttenOut = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_KSLAttenFB`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslAttenFB = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`op1_KSLAttenADSR`):
				if (value >=0 && value <= 255) {
					soundBank[bankNum][presetNum].operators[1].kslAttenADSR = cast(ubyte)value;
					return 0;
				}
				break;
			//op1 end

			//op0 flags begin
			case hashCalc(`op0f_FBMode`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.FBMode;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.FBMode;
				}
				return 0;
			case hashCalc(`op0f_FBNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.FBNeg;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.FBNeg;
				}
				return 0;
			case hashCalc(`op0f_MWNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.MWNeg;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.MWNeg;
				}
				return 0;
			case hashCalc(`op0f_VelNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.VelNeg;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.VelNeg;
				}
				return 0;
			case hashCalc(`op0f_EGRelAdaptive`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.EGRelAdaptive;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.EGRelAdaptive;
				}
				return 0;
			case hashCalc(`op0f_FixedPitch`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.FixedPitch;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.FixedPitch;
				}
				return 0;
			case hashCalc(`op0f_EasyTune`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.EasyTune;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.EasyTune;
				}
				return 0;
			case hashCalc(`op0f_ContiTune`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.ContiTune;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.ContiTune;
				}
				return 0;
			case hashCalc(`op0f_ExprToMW`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[0].opCtrl &= ~OpCtrlFlags.ExprToMW;
				} else {
					soundBank[bankNum][presetNum].operators[0].opCtrl |= OpCtrlFlags.ExprToMW;
				}
				return 0;
			//op0 flags end

			//op1 flags begin
			case hashCalc(`op1f_FBMode`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.FBMode;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.FBMode;
				}
				return 0;
			case hashCalc(`op1f_FBNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.FBNeg;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.FBNeg;
				}
				return 0;
			case hashCalc(`op1f_MWNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.MWNeg;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.MWNeg;
				}
				return 0;
			case hashCalc(`op1f_VelNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.VelNeg;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.VelNeg;
				}
				return 0;
			case hashCalc(`op1f_EGRelAdaptive`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.EGRelAdaptive;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.EGRelAdaptive;
				}
				return 0;
			case hashCalc(`op1f_FixedPitch`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.FixedPitch;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.FixedPitch;
				}
				return 0;
			case hashCalc(`op1f_EasyTune`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.EasyTune;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.EasyTune;
				}
				return 0;
			case hashCalc(`op1f_ContiTune`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.ContiTune;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.ContiTune;
				}
				return 0;
			case hashCalc(`op1f_ExprToMW`):
				if (value == 0) {
					soundBank[bankNum][presetNum].operators[1].opCtrl &= ~OpCtrlFlags.ExprToMW;
				} else {
					soundBank[bankNum][presetNum].operators[1].opCtrl |= OpCtrlFlags.ExprToMW;
				}
				return 0;
			//op1 flags end

			//ch begin
			case hashCalc(`ch_Attack`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].channel.atkX = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`ch_Decay`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].channel.decX = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`ch_SusCtrl`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].channel.susCCX = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`ch_Release`):
				if (value >=0 && value <= 127) {
					soundBank[bankNum][presetNum].channel.relX = cast(ubyte)value;
					return 0;
				}
				break;
			//ch end

			//ch flags begins
			case hashCalc(`chf_ComboMode`):
				if (value >= 0 && value <=3) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.ComboModeTest;
					soundBank[bankNum][presetNum].channel.chCtrl |= value;
					return 0;
				}
				break;
			case hashCalc(`chf_Algorithm`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.Algorithm;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.Algorithm;
				}
				return 0;
			case hashCalc(`chf_IndivOutChLev`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.IndivOutChLev;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.IndivOutChLev;
				}
				return 0;
			case hashCalc(`chf_LFOPan`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.LFOPan;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.LFOPan;
				}
				return 0;
			case hashCalc(`chf_EEGPan`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.EEGPan;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.EEGPan;
				}
				return 0;
			case hashCalc(`chf_MWToTrem`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.MWToTrem;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.MWToTrem;
				}
				return 0;
			case hashCalc(`chf_MWToVibr`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.MWToVibr;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.MWToVibr;
				}
				return 0;
			case hashCalc(`chf_MWToAux`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.MWToAux;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.MWToAux;
				}
				return 0;
			case hashCalc(`chf_ResetOnKeyOn`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.ResetOnKeyOn;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.ResetOnKeyOn;
				}
				return 0;
			case hashCalc(`chf_ResetMode`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.ResetMode;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.ResetMode;
				}
				return 0;
			case hashCalc(`chf_FBMode`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.FBMode;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.FBMode;
				}
				return 0;
			case hashCalc(`chf_FBNeg`):
				if (value == 0) {
					soundBank[bankNum][presetNum].channel.chCtrl &= ~ChCtrlFlags.FBNeg;
				} else {
					soundBank[bankNum][presetNum].channel.chCtrl |= ChCtrlFlags.FBNeg;
				}
				return 0;
			//ch flags end

			//common values begin
			case hashCalc(`_PLFOWF`):
				if (value >=0 && value <= 127){
					lfoWaveform[0] = cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`_ALFOWF`):
				if (value >=0 && value <= 127) {
					lfoWaveform[1] &= 0b1000_0000;
					lfoWaveform[1] |= cast(ubyte)value;
					return 0;
				}
				break;
			case hashCalc(`_Ringmod`):
				if (value == 0)
					lfoWaveform[1] &= 0b0111_1111;
				else
					lfoWaveform[1] |= 0b1000_0000;
				return 0;
			//common values end
			default:
				return 1;
		}
		return 2;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int writeParam_long(uint presetID, uint paramID, long value) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//case hashCalc(`op0_Tune`):break;
			case hashCalc(`op0_OpCtrl`):
				soundBank[bankNum][presetNum].operators[0].opCtrl = cast(uint)value;
				break;

			//case hashCalc(`op1_Tune`):break;
			case hashCalc(`op1_OpCtrl`):
				soundBank[bankNum][presetNum].operators[1].opCtrl = cast(uint)value;
				break;

			case hashCalc(`ch_ChCtrl`):
				soundBank[bankNum][presetNum].channel.chCtrl = cast(uint)value;
				break;
			default:
				return 1;
		}
		return 0;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int writeParam_double(uint presetID, uint paramID, double value) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//op0 begin
			case hashCalc(`op0_Level`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].outL = value;
					return 0;
				}
				break;
			case hashCalc(`op0_SusLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].susLevel = value;
					return 0;
				}
				break;
			case hashCalc(`op0_Feedback`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].fbL = value;
					return 0;
				}
				break;
			case hashCalc(`op0_Tune`):
				soundBank[bankNum][presetNum].operators[0].tune = value;
				
				return 0;
			//case hashCalc(`op0_FreqRate`):break;
			case hashCalc(`op0_ShpA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].shpA = value;
					return 0;
				}
				break;
			case hashCalc(`op0_ShpR`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].shpR = value;
					return 0;
				}
				break;
			case hashCalc(`op0_VelToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].outLCtrl[0] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_MWToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].outLCtrl[1] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_LFOToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].outLCtrl[2] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_VelToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].fbLCtrl[0] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_MWToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].fbLCtrl[1] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_LFOToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].fbLCtrl[2] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_EEGToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].fbLCtrl[3] = value;
					return 0;
				}
				break;
			case hashCalc(`op0_VelToShpA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].shpAVel = value;
					return 0;
				}
				break;
			case hashCalc(`op0_VelToShpR`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[0].shpRVel = value;
					return 0;
				}
				break;
			//op0 end

			//op1 begin
			case hashCalc(`op1_Level`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].outL = value;
					return 0;
				}
				break;
			case hashCalc(`op1_SusLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].susLevel = value;
					return 0;
				}
				break;
			case hashCalc(`op1_Feedback`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].fbL = value;
					return 0;
				}
				break;
			case hashCalc(`op1_Tune`):
				soundBank[bankNum][presetNum].operators[1].tune = value;
				
				return 0;
			//case hashCalc(`op1_FreqRate`):break;
			case hashCalc(`op1_ShpA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].shpA = value;
					return 0;
				}
				break;
			case hashCalc(`op1_ShpR`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].shpR = value;
					return 0;
				}
				break;
			case hashCalc(`op1_VelToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].outLCtrl[0] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_MWToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].outLCtrl[1] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_LFOToLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].outLCtrl[2] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_VelToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].fbLCtrl[0] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_MWToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].fbLCtrl[1] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_LFOToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].fbLCtrl[2] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_EEGToFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].fbLCtrl[3] = value;
					return 0;
				}
				break;
			case hashCalc(`op1_VelToShpA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].shpAVel = value;
					return 0;
				}
				break;
			case hashCalc(`op1_VelToShpR`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].operators[1].shpRVel = value;
					return 0;
				}
				break;
			//op1 end

			//ch begin
			case hashCalc(`ch_MasterVol`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.masterVol = value;
					return 0;
				}
				break;
			case hashCalc(`ch_Bal`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.masterBal = value;
					return 0;
				}
				break;
			case hashCalc(`ch_AuxSLA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.auxSendA = value;
					return 0;
				}
				break;
			case hashCalc(`ch_AuxSLB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.auxSendB = value;
					return 0;
				}
				break;
			case hashCalc(`ch_EEGDetune`):
				soundBank[bankNum][presetNum].channel.eegDetuneAm = value;
				return 0;
			case hashCalc(`ch_PitchBendSens`):
				soundBank[bankNum][presetNum].channel.pitchBendSens = value;
				return 0;
			case hashCalc(`ch_Tune`):
				soundBank[bankNum][presetNum].channel.chnlTun = value;
				return 0;
			case hashCalc(`ch_PLFO`):
				soundBank[bankNum][presetNum].channel.pLFOlevel = value;
				return 0;
			case hashCalc(`ch_SusLevel`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.susLevel = value;
					return 0;
				}
				break;
			case hashCalc(`ch_ShpA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.shpAX = value;
					return 0;
				}
				break;
			case hashCalc(`ch_ShpR`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.shpRX = value;
					return 0;
				}
				break;
			case hashCalc(`ch_GlobalFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.globalFb = value;
					return 0;
				}
				break;
			case hashCalc(`ch_EEGToLeft`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.eegLevels[0] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_EEGToRight`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.eegLevels[1] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_EEGToAuxA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.eegLevels[2] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_EEGToAuxB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.eegLevels[3] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_LFOToLeft`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.aLFOlevels[0] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_LFOToRight`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.aLFOlevels[1] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_LFOToAuxA`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.aLFOlevels[2] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_LFOToAuxB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.aLFOlevels[3] = value;
					return 0;
				}
				break;
			case hashCalc(`ch_MWToGFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.mwToGFB = value;
					return 0;
				}
				break;
			case hashCalc(`ch_VelToGFB`):
				if (value >= 0 && value <= 1) {
					soundBank[bankNum][presetNum].channel.velToGFB = value;
					return 0;
				}
				break;
			//ch end

			//commons begin
			case hashCalc(`_PLFORate`):
				pLFOFreq = value;
				setPLFO();
				return 0;
			case hashCalc(`_ALFORate`):
				aLFOFreq = value;
				setALFO();
				return 0;
			case hashCalc(`_FilterLCFreq`):
				filterCtrl[0] = value;
				return 0;
			case hashCalc(`_FilterLCQ`):
				filterCtrl[1] = value;
				return 0;
			case hashCalc(`_FilterRCFreq`):
				filterCtrl[2] = value;
				return 0;
			case hashCalc(`_FilterRCQ`):
				filterCtrl[3] = value;
				return 0;
			case hashCalc(`_FilterACFreq`):
				filterCtrl[4] = value;
				return 0;
			case hashCalc(`_FilterACQ`):
				filterCtrl[5] = value;
				return 0;
			case hashCalc(`_FilterBCFreq`):
				filterCtrl[6] = value;
				return 0;
			case hashCalc(`_FilterBCQ`):
				filterCtrl[7] = value;
				return 0;
			case hashCalc(`_HPFLCFreq`):
				hpfCtrl[0] = value;
				resetHPF(0);
				return 0;
			case hashCalc(`_HPFLCQ`):
				hpfCtrl[1] = value;
				resetHPF(0);
				return 0;
			case hashCalc(`_HPFRCFreq`):
				hpfCtrl[2] = value;
				resetHPF(1);
				return 0;
			case hashCalc(`_HPFRCQ`):
				hpfCtrl[3] = value;
				resetHPF(1);
				return 0;
			case hashCalc(`_HPFACFreq`):
				hpfCtrl[4] = value;
				resetHPF(2);
				return 0;
			case hashCalc(`_HPFACQ`):
				hpfCtrl[5] = value;
				resetHPF(2);
				return 0;
			case hashCalc(`_HPFBCFreq`):
				hpfCtrl[6] = value;
				resetHPF(3);
				return 0;
			case hashCalc(`_HPFBCQ`):
				hpfCtrl[6] = value;
				resetHPF(3);
				return 0;
			//commons end
			default:
				return 1;
		}
		return 2;
	}
	/**
	 * Restores a parameter to the given preset.
	 * Returns an errorcode on failure.
	 */
	public override int writeParam_string(uint presetID, uint paramID, string value) nothrow {
		return 0;
	}
	/** 
	 * Returns all the possible parameters this module has.
	 */
	public override MValue[] getParameters() nothrow {
		return [
			MValue(MValueType.Float,`op0_Level`), MValue(MValueType.Int32,`op0_Attack`), MValue(MValueType.Int32,`op0_Decay`), 
			MValue(MValueType.Float,`op0_SusLevel`), MValue(MValueType.Int32,`op0_SusCtrl`), 
			MValue(MValueType.Int32,`op0_Release`), MValue(MValueType.Int32,`op0_Waveform`), 
			MValue(MValueType.Float,`op0_Feedback`), MValue(MValueType.Int32,`op0_TuneCor`), 
			MValue(MValueType.Float,`op0_TuneFine`), MValue(MValueType.Float,`op0_ShpA`),
			MValue(MValueType.Float,`op0_0ShpR`), MValue(MValueType.Float,`op0_VelToLevel`), 
			MValue(MValueType.Float,`op0_MWToLevel`), MValue(MValueType.Float,`op0_LFOToLevel`), 
			MValue(MValueType.Int64,`op0_OpCtrl`), MValue(MValueType.Float,`op0_VelToFB`), MValue(MValueType.Float,`op0_MWToFB`), 
			MValue(MValueType.Float,`op0_LFOToFB`), MValue(MValueType.Float,`op0_EEGToFB`),
			MValue(MValueType.Float,`op0_VelToShpA`), MValue(MValueType.Float,`op0_VelToShpR`), 
			MValue(MValueType.Int32,`op0_KSLBegin`), MValue(MValueType.Int32,`op0_KSLAttenOut`), 
			MValue(MValueType.Int32,`op0_KSLAttenFB`), MValue(MValueType.Int32,`op0_KSLAttenADSR`),

			MValue(MValueType.Boolean,`op0f_FBMode`), MValue(MValueType.Boolean,`op0f_FBNeg`), 
			MValue(MValueType.Boolean,`op0f_MWNeg`), MValue(MValueType.Boolean,`op0f_VelNeg`), 
			MValue(MValueType.Boolean,`op0f_EGRelAdaptive`), MValue(MValueType.Boolean,`op0f_FixedPitch`),
			MValue(MValueType.Boolean,`op0f_EasyTune`), MValue(MValueType.Boolean,`op0f_ContiTune`),
			MValue(MValueType.Boolean,`op0f_ExprToMW`),

			MValue(MValueType.Float,`op1_Level`), MValue(MValueType.Int32,`op1_Attack`), MValue(MValueType.Int32,`op1_Decay`), 
			MValue(MValueType.Float,`op1_SusLevel`), MValue(MValueType.Int32,`op1_SusCtrl`), 
			MValue(MValueType.Int32,`op1_Release`), MValue(MValueType.Int32,`op1_Waveform`), 
			MValue(MValueType.Float,`op1_Feedback`), MValue(MValueType.Int32,`op1_TuneCor`), 
			MValue(MValueType.Float,`op1_TuneFine`), MValue(MValueType.Float,`op1_ShpA`),
			MValue(MValueType.Float,`op1_0ShpR`), MValue(MValueType.Float,`op1_VelToLevel`), 
			MValue(MValueType.Float,`op1_MWToLevel`), MValue(MValueType.Float,`op1_LFOToLevel`), 
			MValue(MValueType.Int64,`op1_OpCtrl`), MValue(MValueType.Float,`op1_VelToFB`), MValue(MValueType.Float,`op1_MWToFB`), 
			MValue(MValueType.Float,`op1_LFOToFB`), MValue(MValueType.Float,`op1_EEGToFB`),
			MValue(MValueType.Float,`op1_VelToShpA`), MValue(MValueType.Float,`op1_VelToShpR`), 
			MValue(MValueType.Int32,`op1_KSLBegin`), MValue(MValueType.Int32,`op1_KSLAttenOut`), 
			MValue(MValueType.Int32,`op1_KSLAttenFB`), MValue(MValueType.Int32,`op1_KSLAttenADSR`),

			MValue(MValueType.Boolean,`op1f_FBMode`), MValue(MValueType.Boolean,`op1f_FBNeg`),
			MValue(MValueType.Boolean,`op1f_MWNeg`), MValue(MValueType.Boolean,`op1f_VelNeg`),
			MValue(MValueType.Boolean,`op1f_EGRelAdaptive`), MValue(MValueType.Boolean,`op1f_FixedPitch`),
			MValue(MValueType.Boolean,`op1f_EasyTune`), MValue(MValueType.Boolean,`op1f_ContiTune`),
			MValue(MValueType.Boolean,`op1f_ExprToMW`),

			MValue(MValueType.Float,`ch_MasterVol`), MValue(MValueType.Float,`ch_Bal`), MValue(MValueType.Float,`ch_AuxSLA`),
			MValue(MValueType.Float,`ch_AuxSLB`), MValue(MValueType.Float,`ch_EEGDetune`), MValue(MValueType.Float,`ch_PLFO`),
			MValue(MValueType.Int32,`ch_Attack`), MValue(MValueType.Int32,`ch_Decay`), MValue(MValueType.Float,`ch_SusLevel`),
			MValue(MValueType.Int32,`ch_SusCtrl`), MValue(MValueType.Int32,`ch_Release`), MValue(MValueType.Float,`ch_ShpA`),
			MValue(MValueType.Float,`ch_ShpR`), MValue(MValueType.Float,`ch_GlobalFB`), MValue(MValueType.Int64,`ch_ChCtrl`),
			MValue(MValueType.Float,`ch_EEGToLeft`), MValue(MValueType.Float,`ch_EEGToRight`), 
			MValue(MValueType.Float,`ch_EEGToAuxA`), MValue(MValueType.Float,`ch_EEGToAuxB`), 
			MValue(MValueType.Float,`ch_LFOToLeft`), MValue(MValueType.Float,`ch_LFOToRight`),
			MValue(MValueType.Float,`ch_LFOToAuxA`), MValue(MValueType.Float,`ch_LFOToAuxB`),
			MValue(MValueType.Float,`ch_MWToGFB`), MValue(MValueType.Float,`ch_VelToGFB`),

			MValue(MValueType.Int32,`chf_ComboMode`), MValue(MValueType.Boolean,`chf_Algorithm`),
			MValue(MValueType.Boolean,`chf_IndivOutChLev`), MValue(MValueType.Boolean,`chf_LFOPan`),
			MValue(MValueType.Boolean,`chf_EEGPan`), MValue(MValueType.Boolean,`chf_MWToTrem`), 
			MValue(MValueType.Boolean,`chf_MWToVibr`), MValue(MValueType.Boolean,`chf_MWToAux`),
			MValue(MValueType.Boolean,`chf_ResetOnKeyOn`), MValue(MValueType.Boolean,`chf_ResetMode`),
			MValue(MValueType.Boolean,`chf_FBMode`), MValue(MValueType.Boolean,`chf_FBNeg`),

			MValue(MValueType.Float,`_PLFORate`), MValue(MValueType.Int32,`_PLFOWF`),
			MValue(MValueType.Float,`_ALFORate`), MValue(MValueType.Int32,`_ALFOWF`),
			MValue(MValueType.Float,`_FilterLCFreq`),MValue(MValueType.Float,`_FilterLCQ`),
			MValue(MValueType.Float,`_FilterRCFreq`),MValue(MValueType.Float,`_FilterRCQ`),
			MValue(MValueType.Float,`_FilterACFreq`),MValue(MValueType.Float,`_FilterACQ`),
			MValue(MValueType.Float,`_FilterBCFreq`),MValue(MValueType.Float,`_FilterBCQ`),
			MValue(MValueType.Float,`_HPFLCFreq`),MValue(MValueType.Float,`_HPFLCQ`),
			MValue(MValueType.Float,`_HPFRCFreq`),MValue(MValueType.Float,`_HPFRCQ`),
			MValue(MValueType.Float,`_HPFACFreq`),MValue(MValueType.Float,`_HPFACQ`),
			MValue(MValueType.Float,`_HPFBCFreq`),MValue(MValueType.Float,`_HPFBCQ`),
			MValue(MValueType.Boolean,`_Ringmod`),
			];
	}
	/** 
	 * Reads the given value (int).
	 * Params:
	 *   presetID = The preset ID, or uint.max for global module values.
	 *   paramID = The parameter ID.
	 * Returns: The value of the given preset and parameter
	 */
	public override int readParam_int(uint presetID, uint paramID) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//op0 begin
			case hashCalc(`op0_Attack`):
				return soundBank[bankNum][presetNum].operators[0].atk;
			case hashCalc(`op0_Decay`):
				return soundBank[bankNum][presetNum].operators[0].dec;
			case hashCalc(`op0_SusCtrl`):
				return soundBank[bankNum][presetNum].operators[0].susCC;
			case hashCalc(`op0_Release`):
				return soundBank[bankNum][presetNum].operators[0].rel;
			case hashCalc(`op0_Waveform`):
				return soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.WavetableSelect;
			case hashCalc(`op0_TuneCor`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & TuneCtrlFlags.CorTuneTest)>>>25;
			case hashCalc(`op0_KSLBegin`):
				return soundBank[bankNum][presetNum].operators[0].kslBegin;
			case hashCalc(`op0_KSLAttenOut`):
				return soundBank[bankNum][presetNum].operators[0].kslAttenOut;
			case hashCalc(`op0_KSLAttenFB`):
				return soundBank[bankNum][presetNum].operators[1].kslAttenFB;
			case hashCalc(`op0_KSLAttenADSR`):
				return soundBank[bankNum][presetNum].operators[1].kslAttenADSR;
			//op0 end

			//op1 begin
			case hashCalc(`op1_Attack`):
				return soundBank[bankNum][presetNum].operators[1].atk;
			case hashCalc(`op1_Decay`):
				return soundBank[bankNum][presetNum].operators[1].dec;
			case hashCalc(`op1_SusCtrl`):
				return soundBank[bankNum][presetNum].operators[1].susCC;
			case hashCalc(`op1_Release`):
				return soundBank[bankNum][presetNum].operators[1].rel;
			case hashCalc(`op1_Waveform`):
				return soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.WavetableSelect;
			case hashCalc(`op1_TuneCor`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & TuneCtrlFlags.CorTuneTest)>>25;
			case hashCalc(`op1_KSLBegin`):
				return soundBank[bankNum][presetNum].operators[1].kslBegin;
			case hashCalc(`op1_KSLAttenOut`):
				return soundBank[bankNum][presetNum].operators[1].kslAttenOut;
			case hashCalc(`op1_KSLAttenFB`):
				return soundBank[bankNum][presetNum].operators[1].kslAttenFB;
			case hashCalc(`op1_KSLAttenADSR`):
				return soundBank[bankNum][presetNum].operators[1].kslAttenADSR;
			//op1 end

			//op0 flags begin
			case hashCalc(`op0f_FBMode`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.FBMode) ? 1 : 0;
			case hashCalc(`op0f_FBNeg`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.FBNeg) ? 1 : 0;
			case hashCalc(`op0f_MWNeg`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.MWNeg) ? 1 : 0;
			case hashCalc(`op0f_VelNeg`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.VelNeg) ? 1 : 0;
			case hashCalc(`op0f_EGRelAdaptive`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.EGRelAdaptive) ? 1 : 0;
			case hashCalc(`op0f_FixedPitch`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.FixedPitch) ? 1 : 0;
			case hashCalc(`op0f_EasyTune`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.EasyTune) ? 1 : 0;
			case hashCalc(`op0f_ContiTune`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.ContiTune) ? 1 : 0;
			case hashCalc(`op0f_ExprToMW`):
				return (soundBank[bankNum][presetNum].operators[0].opCtrl & OpCtrlFlags.ExprToMW) ? 1 : 0;
			//op0 flags end

			//op1 flags begin
			case hashCalc(`op1f_FBMode`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.FBMode) ? 1 : 0;
			case hashCalc(`op1f_FBNeg`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.FBNeg) ? 1 : 0;
			case hashCalc(`op1f_MWNeg`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.MWNeg) ? 1 : 0;
			case hashCalc(`op1f_VelNeg`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.VelNeg) ? 1 : 0;
			case hashCalc(`op1f_EGRelAdaptive`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.EGRelAdaptive) ? 1 : 0;
			case hashCalc(`op1f_FixedPitch`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.FixedPitch) ? 1 : 0;
			case hashCalc(`op1f_EasyTune`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.EasyTune) ? 1 : 0;
			case hashCalc(`op1f_ContiTune`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.ContiTune) ? 1 : 0;
			case hashCalc(`op1f_ExprToMW`):
				return (soundBank[bankNum][presetNum].operators[1].opCtrl & OpCtrlFlags.ExprToMW) ? 1 : 0;
			//op1 flags end

			//ch begin
			case hashCalc(`ch_Attack`):
				return soundBank[bankNum][presetNum].channel.atkX;
			case hashCalc(`ch_Decay`):
				return soundBank[bankNum][presetNum].channel.decX;
			case hashCalc(`ch_SusCtrl`):
				return soundBank[bankNum][presetNum].channel.susCCX;
			case hashCalc(`ch_Release`):
				return soundBank[bankNum][presetNum].channel.relX;
			//ch end

			//ch flags begins
			case hashCalc(`chf_ComboMode`):
				return soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.ComboModeTest;
			case hashCalc(`chf_Algorithm`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.Algorithm) ? 1 : 0;
			case hashCalc(`chf_IndivOutChLev`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.IndivOutChLev) ? 1 : 0;
			case hashCalc(`chf_LFOPan`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.LFOPan) ? 1 : 0;
			case hashCalc(`chf_EEGPan`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.EEGPan) ? 1 : 0;
			case hashCalc(`chf_MWToTrem`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.MWToTrem) ? 1 : 0;
			case hashCalc(`chf_MWToVibr`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.MWToVibr) ? 1 : 0;
			case hashCalc(`chf_MWToAux`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.MWToAux) ? 1 : 0;
			case hashCalc(`chf_ResetOnKeyOn`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.ResetOnKeyOn) ? 1 : 0;
			case hashCalc(`chf_ResetMode`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.ResetMode) ? 1 : 0;
			case hashCalc(`chf_FBMode`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.FBMode) ? 1 : 0;
			case hashCalc(`chf_FBNeg`):
				return (soundBank[bankNum][presetNum].channel.chCtrl & ChCtrlFlags.FBNeg) ? 1 : 0;
			//ch flags end

			//common values begin
			case hashCalc(`_PLFOWF`):
				return lfoWaveform[0];
			case hashCalc(`_ALFOWF`):
				return lfoWaveform[1] & 0b0111_1111;
			case hashCalc(`_Ringmod`):
				return (lfoWaveform[1] & 0b1000_0000) ? 1 : 0;
			//common values end
			default:
				return 0;
		}
	}
	/** 
	 * Reads the given value (int).
	 * Params:
	 *   presetID = The preset ID, or uint.max for global module values.
	 *   paramID = The parameter ID.
	 * Returns: The value of the given preset and parameter
	 */
	public override long readParam_long(uint presetID, uint paramID) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//case hashCalc(`op0_Tune`):break;
			case hashCalc(`op0_OpCtrl`):
				return soundBank[bankNum][presetNum].operators[0].opCtrl;

			//case hashCalc(`op1_Tune`):break;
			case hashCalc(`op1_OpCtrl`):
				return soundBank[bankNum][presetNum].operators[1].opCtrl;

			case hashCalc(`ch_ChCtrl`):
				return soundBank[bankNum][presetNum].channel.chCtrl;
			default:
				return 0;
		}
	}
	/** 
	 * Reads the given value (int).
	 * Params:
	 *   presetID = The preset ID, or uint.max for global module values.
	 *   paramID = The parameter ID.
	 * Returns: The value of the given preset and parameter
	 */
	public override double readParam_double(uint presetID, uint paramID) nothrow {
		const ubyte bankNum = cast(ubyte)(presetID>>7), presetNum = cast(ubyte)(presetID & 127);
		switch (paramID) {
			//op0 begin
			case hashCalc(`op0_Level`):
				return soundBank[bankNum][presetNum].operators[0].outL;
			case hashCalc(`op0_SusLevel`):
				return soundBank[bankNum][presetNum].operators[0].susLevel;
			case hashCalc(`op0_Feedback`):
				return soundBank[bankNum][presetNum].operators[0].fbL;
			case hashCalc(`op0_Tune`):
				return soundBank[bankNum][presetNum].operators[0].tune;
			//case hashCalc(`op0_FreqRate`):break;
			case hashCalc(`op0_ShpA`):
				return soundBank[bankNum][presetNum].operators[0].shpA;
			case hashCalc(`op0_ShpR`):
				return soundBank[bankNum][presetNum].operators[0].shpR;
			case hashCalc(`op0_VelToLevel`):
				return soundBank[bankNum][presetNum].operators[0].outLCtrl[0];
			case hashCalc(`op0_MWToLevel`):
				return soundBank[bankNum][presetNum].operators[0].outLCtrl[1];
			case hashCalc(`op0_LFOToLevel`):
				return soundBank[bankNum][presetNum].operators[0].outLCtrl[2];
			case hashCalc(`op0_VelToFB`):
				return soundBank[bankNum][presetNum].operators[0].fbLCtrl[0];
			case hashCalc(`op0_MWToFB`):
				return soundBank[bankNum][presetNum].operators[0].fbLCtrl[1];

			case hashCalc(`op0_LFOToFB`):
				return soundBank[bankNum][presetNum].operators[0].fbLCtrl[2];
			case hashCalc(`op0_EEGToFB`):
				return soundBank[bankNum][presetNum].operators[0].fbLCtrl[3];
			case hashCalc(`op0_VelToShpA`):
				return soundBank[bankNum][presetNum].operators[0].shpAVel;
			case hashCalc(`op0_VelToShpR`):
				return soundBank[bankNum][presetNum].operators[0].shpRVel;
			//op0 end

			//op1 begin
			case hashCalc(`op1_Level`):
				return soundBank[bankNum][presetNum].operators[1].outL;
			case hashCalc(`op1_SusLevel`):
				return soundBank[bankNum][presetNum].operators[1].susLevel;
			case hashCalc(`op1_Feedback`):
				return soundBank[bankNum][presetNum].operators[1].fbL;
			case hashCalc(`op1_Tune`):
				return soundBank[bankNum][presetNum].operators[1].tune;
			//case hashCalc(`op1_FreqRate`):break;
			case hashCalc(`op1_ShpA`):
				return soundBank[bankNum][presetNum].operators[1].shpA;
			case hashCalc(`op1_ShpR`):
				return soundBank[bankNum][presetNum].operators[1].shpR;
			case hashCalc(`op1_VelToLevel`):
				return soundBank[bankNum][presetNum].operators[1].outLCtrl[0];
			case hashCalc(`op1_MWToLevel`):
				return soundBank[bankNum][presetNum].operators[1].outLCtrl[1];
			case hashCalc(`op1_LFOToLevel`):
				return soundBank[bankNum][presetNum].operators[1].outLCtrl[2];
			case hashCalc(`op1_VelToFB`):
				return soundBank[bankNum][presetNum].operators[1].fbLCtrl[0];
			case hashCalc(`op1_MWToFB`):
				return soundBank[bankNum][presetNum].operators[1].fbLCtrl[1];
			case hashCalc(`op1_LFOToFB`):
				return soundBank[bankNum][presetNum].operators[1].fbLCtrl[2];
			case hashCalc(`op1_EEGToFB`):
				return soundBank[bankNum][presetNum].operators[1].fbLCtrl[3];
			case hashCalc(`op1_VelToShpA`):
				return soundBank[bankNum][presetNum].operators[1].shpAVel;
			case hashCalc(`op1_VelToShpR`):
				return soundBank[bankNum][presetNum].operators[1].shpRVel;
			//op1 end

			//ch begin
			case hashCalc(`ch_MasterVol`):
				return soundBank[bankNum][presetNum].channel.masterVol;
			case hashCalc(`ch_Bal`):
				return soundBank[bankNum][presetNum].channel.masterBal;
			case hashCalc(`ch_AuxSLA`):
				return soundBank[bankNum][presetNum].channel.auxSendA;
			case hashCalc(`ch_AuxSLB`):
				return soundBank[bankNum][presetNum].channel.auxSendB;
			case hashCalc(`ch_EEGDetune`):
				return soundBank[bankNum][presetNum].channel.eegDetuneAm;
			case hashCalc(`ch_PitchBendSens`):
				return soundBank[bankNum][presetNum].channel.pitchBendSens;
			case hashCalc(`ch_Tune`):
				return soundBank[bankNum][presetNum].channel.chnlTun;
			case hashCalc(`ch_PLFO`):
				return soundBank[bankNum][presetNum].channel.pLFOlevel;
			case hashCalc(`ch_SusLevel`):
				return soundBank[bankNum][presetNum].channel.susLevel;
			case hashCalc(`ch_ShpA`):
				return soundBank[bankNum][presetNum].channel.shpAX;
			case hashCalc(`ch_ShpR`):
				return soundBank[bankNum][presetNum].channel.shpRX;
			case hashCalc(`ch_GlobalFB`):
				return soundBank[bankNum][presetNum].channel.globalFb;
			case hashCalc(`ch_EEGToLeft`):
				return soundBank[bankNum][presetNum].channel.eegLevels[0];
			case hashCalc(`ch_EEGToRight`):
				return soundBank[bankNum][presetNum].channel.eegLevels[1];
			case hashCalc(`ch_EEGToAuxA`):
				return soundBank[bankNum][presetNum].channel.eegLevels[2];
			case hashCalc(`ch_EEGToAuxB`):
				return soundBank[bankNum][presetNum].channel.eegLevels[3];
			case hashCalc(`ch_LFOToLeft`):
				return soundBank[bankNum][presetNum].channel.aLFOlevels[0];
			case hashCalc(`ch_LFOToRight`):
				return soundBank[bankNum][presetNum].channel.aLFOlevels[1];
			case hashCalc(`ch_LFOToAuxA`):
				return soundBank[bankNum][presetNum].channel.aLFOlevels[2];
			case hashCalc(`ch_LFOToAuxB`):
				return soundBank[bankNum][presetNum].channel.aLFOlevels[3];
			case hashCalc(`ch_MWToGFB`):
				return soundBank[bankNum][presetNum].channel.mwToGFB;
			case hashCalc(`ch_VelToGFB`):
				return soundBank[bankNum][presetNum].channel.velToGFB;
			//ch end

			//commons begin
			case hashCalc(`_PLFORate`): return pLFOFreq;
			case hashCalc(`_ALFORate`): return aLFOFreq;
			case hashCalc(`_FilterLCFreq`):
				return filterCtrl[0];
			case hashCalc(`_FilterLCQ`):
				return filterCtrl[1];
			case hashCalc(`_FilterRCFreq`):
				return filterCtrl[2];
			case hashCalc(`_FilterRCQ`):
				return filterCtrl[3];
			case hashCalc(`_FilterACFreq`):
				return filterCtrl[4];
			case hashCalc(`_FilterACQ`):
				return filterCtrl[5];
			case hashCalc(`_FilterBCFreq`):
				return filterCtrl[6];
			case hashCalc(`_FilterBCQ`):
				return filterCtrl[7];
			case hashCalc(`_HPFLCFreq`):
				return hpfCtrl[0];
			case hashCalc(`_HPFLCQ`):
				return hpfCtrl[1];
			case hashCalc(`_HPFRCFreq`):
				return hpfCtrl[2];
			case hashCalc(`_HPFRCQ`):
				return hpfCtrl[3];
			case hashCalc(`_HPFACFreq`):
				return hpfCtrl[4];
			case hashCalc(`_HPFACQ`):
				return hpfCtrl[5];
			case hashCalc(`_HPFBCFreq`):
				return hpfCtrl[6];
			case hashCalc(`_HPFBCQ`):
				return hpfCtrl[6];
			//commons end
			default:
				return double.nan;
		}
		
	}
	/** 
	 * Reads the given value (int).
	 * Params:
	 *   presetID = The preset ID, or uint.max for global module values.
	 *   paramID = The parameter ID.
	 * Returns: The value of the given preset and parameter
	 */
	public override string readParam_string(uint presetID, uint paramID) nothrow {
		return null;
	}
}
